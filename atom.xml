<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nineteen</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.nineteen.me/"/>
  <updated>2017-09-17T02:52:38.000Z</updated>
  <id>http://www.nineteen.me/</id>
  
  <author>
    <name>郑祯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>刨根问底，Block竟然是？</title>
    <link href="http://www.nineteen.me/2017/09/17/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%EF%BC%8CBlock%E7%AB%9F%E7%84%B6%E6%98%AF%EF%BC%9F/"/>
    <id>http://www.nineteen.me/2017/09/17/刨根问底，Block竟然是？/</id>
    <published>2017-09-17T02:51:44.000Z</published>
    <updated>2017-09-17T02:52:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于iOS开发者来说，Block就像一件哆啦A梦口袋中的宝贝，帮助我们简化代码，实现功能。但是哆啦A梦这部动画片中并没有人好奇这些宝贝是如何实现的，但是作为程序猿，应该要学会刨根问底，了解本质，本文，就深入浅出地讲解Block的实现。<br><a id="more"></a></p>
<h5 id="初步了解Block"><a href="#初步了解Block" class="headerlink" title="初步了解Block"></a>初步了解Block</h5><p>block是基于C语言的扩展功能。block有一个比较常见的说法，叫做：带有自动变量的匿名函数，第一眼看上去有些陌生，我们抓住关键字来理解一下，首先匿名函数，即为没有名字的函数，我们尝试用函数指针来实现一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int function(int a) &#123;</div><div class="line">  cout &lt;&lt; a &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line">int (* functionPointer) (int) = &amp;function;</div><div class="line">int result = (*function)(19);</div></pre></td></tr></table></figure>
<p>注意看最后一行，我们通过函数指针去调用了函数，并不知道函数名。接着还有关键字是带有自动变量，这里的自动变量也就是局部变量，到这里，我们来看看block语法：<br><code>^</code> <code>返回值类型</code> <code>参数列表</code> <code>表达式</code><br>举个例子看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^ int (int a) &#123; return a * a; &#125;;</div></pre></td></tr></table></figure>
<p>同样我们像之前函数指针的赋值一样，将Block语法赋值给声明为Block类型的变量中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int (^blk) (int) = ^ int (int a) &#123; return a * a; &#125;;</div></pre></td></tr></table></figure>
<p>调用则为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blk(19);</div></pre></td></tr></table></figure>
<p>通过对比赋值匿名函数和赋值Block类型变量可以发现，两者的写法即为相似，区别在于<strong>block中为^符号，而函数为*符号</strong>。<br>这里可能大家有个疑惑，那截获自动变量是什么意思呢，我们带着这个问题继续往下。</p>
<h5 id="截获自动变量"><a href="#截获自动变量" class="headerlink" title="截获自动变量"></a>截获自动变量</h5><p>我们先从下面一个场景入手</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int value = 0;</div><div class="line">void (^blk) (void) = ^&#123; printf(&quot;%d&quot;, value); &#125;;</div><div class="line">value = 19;</div><div class="line">blk();</div></pre></td></tr></table></figure>
<p>对block有了解的人都知道，以上输出应该是0，而不是19，在表面上大家就可以理解为<strong>block截获了变量的瞬间值</strong></p>
<h5 id="一、通过源码来究其本质"><a href="#一、通过源码来究其本质" class="headerlink" title="一、通过源码来究其本质"></a>一、通过源码来究其本质</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">    void(^blk)(void) = ^ &#123;</div><div class="line">        printf(&quot;%d&quot;, 19);</div><div class="line">    &#125;;</div><div class="line">    blk();</div><div class="line">    return 0;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用<code>clang -rewrite-objc</code>指令来将以上代码解析为C++源代码：具体转化的代码如下（<strong>这段源码看上去很复杂，但却是我们理解block本地的必经之路</strong>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">        printf(&quot;%d&quot;, 19);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">    void(*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们从main函数入手，看看到底发生了什么变化，我们将main函数中类型转换的操作去掉，简化后的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    void(*blk)(void) = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进一步分解为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    struct __main_block_impl_0 temp = __main_block_impl_0(__main_block_func_0, &amp;_main_block_desc_0_DATA);</div><div class="line">    struct __main_block_impl_0 *blk = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面可以理解为，编译之后的block是结构体类型的，声明的blk是一个指向结构体类型block的指针。<br>了解了基本的之后，再来看其中所涉及到的结构体类型是如何定义的，我们从<code>__main_block_impl_0</code>开始（这个结构体名的命名规则是：<strong>Block所属的函数+Blcok语法在该函数出现的顺序</strong>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>该结构体中定义了两个成员，<code>impl</code>和<code>Desc</code>，同时拥有一个结构体初始化方法（main函数中调用的方法），其中对<code>impl</code>的几个成员变量赋值，同时赋值了<code>Desc</code>。<br>再来看看成员之一的<code>__block_impl</code>结构体是如何定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们主要关注这个几个成员：</p>
<ul>
<li><strong>*isa</strong>：指向类的指针</li>
<li><strong>*FuncPtr</strong>：在main函数中初始化时我们可以注意到是将<code>__main_block_func_0</code>（一个静态函数）赋值给了它</li>
</ul>
<p>接着再来看看另外一个成员<code>__main_block_desc_0</code>是如何定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div></pre></td></tr></table></figure>
<p>从main函数中初始化可以看出将<code>__main_block_des_0</code>类型的变量<code>__main_block_desc_0_DATA</code>传入赋值</p>
<p><strong>基本了解了各个部分之后，我们先进行一下总结：</strong></p>
<ul>
<li><strong>声明block</strong>：创建了一个<code>__main_block_imp_0</code>类型的结构体，并用一个该类型的指针指向这个结构体</li>
<li><strong>使用block</strong>：调用了结构体中的成员<code>__block_impl</code>的<code>FuncPtr</code>方法</li>
</ul>
<h5 id="二、截获自动变量的源代码分析"><a href="#二、截获自动变量的源代码分析" class="headerlink" title="二、截获自动变量的源代码分析"></a>二、截获自动变量的源代码分析</h5><p>通过刚才的理解，大致知道了编译之后的代码构成，但是上述代码并没有截获自动变量，我们又重新写了一份截获自动变量的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">    int value = 3;</div><div class="line">    void(^blk)(void) = ^ &#123;</div><div class="line">        printf(&quot;%d&quot;, value);</div><div class="line">    &#125;;</div><div class="line">    blk();</div><div class="line">        </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且继续使用clang将其编译成C++的源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int value;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _value, int flags=0) : value(_value) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  int value = __cself-&gt;value; // bound by copy</div><div class="line"></div><div class="line">        printf(&quot;%d&quot;, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">    int value = 3;</div><div class="line">    void(*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, value));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时，我们只要看一下捕获自动变量和没有捕获自动变量时的区别就能够理解它的实现原理。<br>我们仍然从<code>main</code>函数入手，可以发现唯一发生变化的是：<code>__main_block_impl_0</code>结构体初始化参数多了一个<code>value</code>，这个<code>value</code>也正是我们block截获的自动变量。<br>那么我们就再来看看<code>__main_block_impl_0</code>结构体定义中出现了什么变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int value; // 1</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _value, int flags=0) : value(_value) &#123; // 2</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>从上面的标记可以看出，有两个地方存在不同</p>
<ol>
<li>结构体中存在一个<code>int</code>类型的成员（和截获值相同类型和名字）</li>
<li>初始化方法中将传入值赋值给该成员变量</li>
</ol>
<p>我们返回到<code>main</code>函数中初始化方法中看传入值是被截获的值。</p>
<p>接着我们来看静态方法<code>__main_block_func_0</code>的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  int value = __cself-&gt;value; // bound by copy</div><div class="line"></div><div class="line">        printf(&quot;%d&quot;, value);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们可以发现，参数中的<code>*_cself</code>指针终于派上用场了，这个参数是在<code>main</code>函数中调用该静态方法的时候传入的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div></pre></td></tr></table></figure>
<p>参数为blk，前面也提到了blk是一个指向结构体的指针。<br>可以发现，该静态方法中操作的实际上是结构体本身的成员，而不是block之外的value变量。</p>
<p><strong>到了这里，我们又该进行一次总结了：</strong><br>截获自动变量，从本质上是在结构体内部增加了一个类型和名字一样的成员，并且赋值，从而block操作的都是成员。</p>
<h5 id="三、使用-block修饰符的源码分析"><a href="#三、使用-block修饰符的源码分析" class="headerlink" title="三、使用__block修饰符的源码分析"></a>三、使用__block修饰符的源码分析</h5><p>以上我们分析了没有捕获自动变量的情况以及捕获自动变量的情况，在捕获自动变量时，如果我们修改了捕获的值，就会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Variable is not assignable(missing,__block type specifier)</div></pre></td></tr></table></figure></p>
<p>因为在底层实现上，不允许改变结构体自己的内部成员值，这时，我们就需要加上<code>__block</code>修饰符。<br>我们写以下代码，来实现对捕获的自动变量修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">    __block int value = 3;</div><div class="line">    void(^blk)(void) = ^ &#123;</div><div class="line">        value = 19;</div><div class="line">    &#125;;</div><div class="line">    blk();</div><div class="line">        </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样地，我们通过<code>clang</code>来编程成C++代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div><div class="line">struct __Block_byref_value_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_value_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_value_0 *value; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_value_0 *_value, int flags=0) : value(_value-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_value_0 *value = __cself-&gt;value; // bound by ref</div><div class="line"></div><div class="line">        (value-&gt;__forwarding-&gt;value) = 19;</div><div class="line">    &#125;</div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;value, (void*)src-&gt;value, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;value, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">    __attribute__((__blocks__(byref))) __Block_byref_value_0 value = &#123;(void*)0,(__Block_byref_value_0 *)&amp;value, 0, sizeof(__Block_byref_value_0), 3&#125;;</div><div class="line">    void(*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_value_0 *)&amp;value, 570425344));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，仅仅是多了一个<code>__block</code>修饰符，就多了这么多代码，那么让我们来研究一下，苹果是如何通过<code>__block</code>来实现修改截获的自动变量的呢。<br>这一次我们不从<code>main</code>函数入手，我们从上往下看发现了一个新的结构体类型<code>__Block_byref_value_0</code>，我们来看看这是什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_value_0 &#123;</div><div class="line">  void *__isa; // 1</div><div class="line">__Block_byref_value_0 *__forwarding; // 2</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int value; // 3</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>从上面的三处标记来看：</p>
<ol>
<li>是一个指向类的指针，之前<code>__block_imp</code>中也存在这个指针</li>
<li><code>__forwarding</code>是一个指向自己的指针</li>
<li>被截获的自动变量作为了这个结构体的成员</li>
</ol>
<p>看到这里好像有点明白，苹果将用<code>__block</code>修饰的变量转变成了一个结构体，并在其中持有截获的自动变量。</p>
<p>我们继续往下看，发现<code>__main_block_impl_0</code>中也存在不同，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_value_0 *value; // by ref // 1</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_value_0 *_value, int flags=0) : value(_value-&gt;__forwarding) &#123; // 2</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以发现两有个地方不一样：</p>
<ol>
<li>成员变量变成了刚刚的<code>__Block_byref_value_0</code>类型的指针，名字仍然和截获的自动变量名一致</li>
<li>初始化的时候将传入对象的<code>__forwarding</code>指针赋值给了成员变量的指针</li>
</ol>
<p>我们继续看<code>main</code>函数中是如何初始化的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">    __attribute__((__blocks__(byref))) __Block_byref_value_0 value = &#123;(void*)0,(__Block_byref_value_0 *)&amp;value, 0, sizeof(__Block_byref_value_0), 3&#125;;</div><div class="line">    void(*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_value_0 *)&amp;value, 570425344));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们仍然采用简化的方式来看看逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    // 1</div><div class="line">    __Block_byref_value_0 value = &#123;</div><div class="line">        0,</div><div class="line">        &amp;value,</div><div class="line">        0,</div><div class="line">        sizeof(__Block_byref_value_0), </div><div class="line">        3</div><div class="line">    &#125;;</div><div class="line">    struct __main_block_impl_0 temp = __main_block_impl_0(__main_block_func_0, &amp;_main_block_desc_0_DATA, &amp;value, 570425344); // 2</div><div class="line">    struct __main_block_impl_0 *blk = temp;</div><div class="line">    blk-&gt;FuncPtr(blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过标记中的两点：</p>
<ol>
<li>被<code>__block</code>修饰的变量被编译成了一个结构体变量，并进行了初始化，对照结构体参数可以发现，第二个参数赋值了自身的引用，最后一个参数赋值了截获的自动变量的值。</li>
<li><code>__main_block_impl_0</code>的初始化参数中，传入了value的引用</li>
</ol>
<p>那值是如何改变的呢，我们去看一下调用的这个静态方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_value_0 *value = __cself-&gt;value; // bound by ref</div><div class="line"></div><div class="line">        (value-&gt;__forwarding-&gt;value) = 19;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以发现改变的操作是，利用成员变量value，调用指向自己的指针<code>__forwarding</code>，然后访问成员value的值，从而进行改变。<br>这里可能大家都有个疑问，为什么不直接访问value就行了，还要先调用指向自己的指针，这岂不是多此一举。<br>其实不然，<strong>苹果这样设计是有它自己的目的</strong>，本文打算不做扩展，我们还是围绕这主题继续进行下去。</p>
<p>除了以上不同之外，还可以发现多了两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;value, (void*)src-&gt;value, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;value, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div></pre></td></tr></table></figure>
<p>外层的方法名叫做</p>
<ol>
<li><code>__main_block_copy_0</code></li>
<li><code>__main_block_dispose_0</code></li>
</ol>
<p>内层分别调用</p>
<ol>
<li><code>_Block_object_assign</code></li>
<li><code>_Block_object_dispose</code></li>
</ol>
<p>本文中，我们仅仅知道这两个方法是帮助我们自动进行<code>__Block_byref_value_0</code>结构体变量内存管理的。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本文主要以block源码分析为主，重点理解了block是如何捕获自动变量的，又是如何修改自动变量的。但是关于block，还有很多精妙的设计和知识点，需要我们继续探究。</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul>
<li>《Objective-C高级编程（iOS与OS X多线程和内存管理）》</li>
<li>官方文档</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于iOS开发者来说，Block就像一件哆啦A梦口袋中的宝贝，帮助我们简化代码，实现功能。但是哆啦A梦这部动画片中并没有人好奇这些宝贝是如何实现的，但是作为程序猿，应该要学会刨根问底，了解本质，本文，就深入浅出地讲解Block的实现。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Runtime和它的消息机制</title>
    <link href="http://www.nineteen.me/2017/09/02/Runtime%E5%92%8C%E5%AE%83%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.nineteen.me/2017/09/02/Runtime和它的消息机制/</id>
    <published>2017-09-02T06:45:33.000Z</published>
    <updated>2017-09-02T06:56:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C这门语言，众所周知，是对C进行了扩展，具体来说进行了两个方面的扩展，面向对象的特性和smalltalk中的消息传递。而消息传递机制归根结底是建立在Runtime库上。正是这种机制，决定了Objective-C是一门动态语言，而同样是对C扩展的C++，是静态的。Objective-C将很多决定性的操作依靠Runtime在运行时处理，而C++仅仅在编译时就决定了如何处理<br><a id="more"></a></p>
<h5 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h5><p>在我们所熟悉的调用方法背后，最终都是以消息传递的方式进行处理，例如<code>[object method]</code>，从表面上来看，是object调用了method方法，实际上，在运行时，是给object发送了一条method消息，这条消息不一定非要object来处理，也可以转发给其他的对象处理，也可以不进行处理，这些种种操作，都是利用Runtime在运行时处理的。<br>对于<code>[object method]</code>的调用，编译器会将其编译成一行C语言的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(object, @selector(method));</div></pre></td></tr></table></figure>
<h5 id="消息传递的步骤"><a href="#消息传递的步骤" class="headerlink" title="消息传递的步骤"></a>消息传递的步骤</h5><p>了解了消息传递之后，需要进一步知道消息传递的具体步骤：</p>
<ol>
<li>先查看method方法是不是需要被忽略</li>
<li>查看object对象是否为nil（Objective-C中允许空对象调用任何方法的原因）</li>
<li>查看缓存中是否存在方法，系统把近期发送过的消息记录在其中，苹果认为这样可以提高效率</li>
<li>如果缓存中没有命中，那么查找该类的方法表，依次从后往前查找</li>
<li>如果没有找到，则进入父类查找</li>
<li>如果到了根类还是没有找到的话，那么就进入动态解析</li>
</ol>
<h5 id="Runtime中的基本类型"><a href="#Runtime中的基本类型" class="headerlink" title="Runtime中的基本类型"></a>Runtime中的基本类型</h5><p>以上过程虽然读起来蛮容易理解的，但是我们还得搞清楚Runtime是通过什么进行上述操作的，这时候就需要对Runtime的一些基本类型进行了解，我们可以在<code>objc/objc.h</code>中看到以下这些定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">struct objc_object &#123;  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct objc_class &#123;  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class;</div><div class="line">    const char *name;</div><div class="line">    long version;</div><div class="line">    long info;</div><div class="line">    long instance_size;</div><div class="line">    struct objc_ivar_list *ivars;</div><div class="line">    **struct objc_method_list **methodLists**;</div><div class="line">    **struct objc_cache *cache**;</div><div class="line">    struct objc_protocol_list *protocols;</div><div class="line">#endif</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct objc_method_list &#123;  </div><div class="line">    struct objc_method_list *obsolete;</div><div class="line">    int method_count;</div><div class="line"></div><div class="line">#ifdef __LP64__</div><div class="line">    int space;</div><div class="line">#endif</div><div class="line"></div><div class="line">    /* variable length structure */</div><div class="line">    struct objc_method method_list[1];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct objc_method &#123;  </div><div class="line">    SEL method_name;</div><div class="line">    char *method_types;    /* a string representing argument/return types */</div><div class="line">    IMP method_imp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>不难发现，基本每个结构都是C语言中的结构体，<code>object_object</code>对应着object，<code>object_class</code>对应着对象所属于的类，我们先把目光主要集中在<code>object_class</code>这个结构体上，可以发现几个上述步骤涉及到的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class; // 父类</div><div class="line">    const char *name; // 类名</div><div class="line">    long version; </div><div class="line">    long info;</div><div class="line">    long instance_size;</div><div class="line">    struct objc_ivar_list *ivars;</div><div class="line">    **struct objc_method_list **methodLists**; // 方法列表</div><div class="line">    **struct objc_cache *cache**; // 缓存</div><div class="line">    struct objc_protocol_list *protocols;</div><div class="line">#endif</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="再次理解消息传递的步骤"><a href="#再次理解消息传递的步骤" class="headerlink" title="再次理解消息传递的步骤"></a>再次理解消息传递的步骤</h5><p>理解了Runtime的基本结构后，我们再次用专业的角度来理解消息传递：</p>
<ol>
<li>查看method方法是否需要被忽略</li>
<li>查看object对象是否为nil</li>
<li>通过objc_object中的isa指针，找到该object的objc_class，然后查看objc_cache类型的cache成员中是否有这个方法，如果有，则找到objc_method中的IMP类型（函数指针）的成员method_imp去找到实现内容，并执行。</li>
<li>如果没有找到，则查看objc_method_list类型的成员methodLists中是否有该方法</li>
<li>如果没有找到，则通过Class类型的成员super_class找到父类的objc_class，进行查找</li>
<li>要是还没有找到，则进入动态解析</li>
</ol>
<h5 id="如果是调用类方法呢"><a href="#如果是调用类方法呢" class="headerlink" title="如果是调用类方法呢"></a>如果是调用类方法呢</h5><p>再次查看这个objc_class的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY; // metaclass</div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class;</div><div class="line">    const char *name;</div><div class="line">    long version;</div><div class="line">    long info;</div><div class="line">    long instance_size;</div><div class="line">    struct objc_ivar_list *ivars;</div><div class="line">    **struct objc_method_list **methodLists**;</div><div class="line">    **struct objc_cache *cache**;</div><div class="line">    struct objc_protocol_list *protocols;</div><div class="line">#endif</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>刚刚第一次看的时候可能没有注意到第一个成员，第一个成员指向的是结构是metaclass，其中包含静态成员变量和静态方法（类方法），同时也包含了一个isa成员，都指向了父类的metaclass，如果是根类，则指向自己。所以如果是调用类方法的话，那么就会利用objc_class中的成员isa找到metaclass，然后寻找方法，没有找到的话则仍然进入动态解析。</p>
<h5 id="动态解析"><a href="#动态解析" class="headerlink" title="动态解析"></a>动态解析</h5><p>通过第二次的理解，对于消息传递有了一个清晰的了解，我们继续来研究消息传递最后一步的动态解析。正常我们如果调用了一个没有实现的方法，那么程序会崩溃，并且抛出<code>unrecognized selector to ...</code>的异常，但是利用Runtime，我们可以有三次机会避免程序崩溃，先通过一张图来大致了解下过程：<br><img src="http://upload-images.jianshu.io/upload_images/2070409-1bcb07b36efa1c0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们具体看下三种方法：</p>
<ul>
<li><code>resovleInstanceMethod</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void otherEat(id self, SEL cmd) &#123;</div><div class="line">    NSLog(@&quot;郑明明&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    if ([NSStringFromSelector(sel) isEqualToString:@&quot;eat&quot;]) &#123;</div><div class="line">        class_addMethod(self, sel, (IMP)otherEat, &quot;v@&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上需要注意几个地方：</p>
<ol>
<li><code>otherEat</code>函数是要被<code>class_addMethod</code>作为参数的，而<code>class_addMethod</code>是Runtime中的API，所以是基于C的，<code>otherEat</code>函数应该是C语言格式的函数</li>
<li>class_addMethod方法可谓是核心，那么依次来看他的参数的含义：<ul>
<li>first：添加到哪个类</li>
<li>second：添加哪个SEL选择器</li>
<li>third：IMP函数指针</li>
<li>fourth：IMP指针指向的函数返回值和参数类型<ul>
<li>v@：代表返回值是void类型，无参数<ul>
<li>i@：代表返回值是int类型，无参数</li>
<li>v@:i@：代表返回值是void类型，参数是int类型，存在一个参数（多参数依次累加）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>如果没有调用class_addMethod成功添加方法，那么就会到下一个方法</p>
<ul>
<li><code>forwardingTargetForSelector</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">//    return [[Woman alloc]init];</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果返回了另外一个对象，那么动态解析又会重新以另外一个对象为接受者执行，如果返回nil，则又继续进入到下一个方法</p>
<ul>
<li><code>methodSignatureForSelector</code> + <code>forwardInvocation</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;eat&quot;]) &#123;</div><div class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;@v&quot;];</div><div class="line">    &#125;</div><div class="line">    return [super methodSignatureForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</div><div class="line">    // 改变消息接受对象</div><div class="line">    /*</div><div class="line">    Woman *temp = [[Woman alloc]init];</div><div class="line">    [anInvocation invokeWithTarget:temp];</div><div class="line">     */</div><div class="line">    </div><div class="line">    // 改变执行的消息</div><div class="line">    [anInvocation setSelector:@selector(otherEat)];</div><div class="line">    [anInvocation invokeWithTarget:self];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>methodSignatureForSelector</code>方法返回一个返回值以及参数的封装值，然后会进入到下一个方法，<code>forwardInvocation</code>，这个方法的功能可以说是前两个方法的结合，通过操作NSInvocation对象，既可以改变需执行的消息，又可以改变消息的接受对象</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Runtime为Objective-C提供了很多可能，了解消息机制，更加有助于对Objective-C这门语言特性的掌握 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C这门语言，众所周知，是对C进行了扩展，具体来说进行了两个方面的扩展，面向对象的特性和smalltalk中的消息传递。而消息传递机制归根结底是建立在Runtime库上。正是这种机制，决定了Objective-C是一门动态语言，而同样是对C扩展的C++，是静态的。Objective-C将很多决定性的操作依靠Runtime在运行时处理，而C++仅仅在编译时就决定了如何处理&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中那些精妙的设计模式</title>
    <link href="http://www.nineteen.me/2017/08/29/iOS%E4%B8%AD%E9%82%A3%E4%BA%9B%E7%B2%BE%E5%A6%99%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.nineteen.me/2017/08/29/iOS中那些精妙的设计模式/</id>
    <published>2017-08-29T10:12:03.000Z</published>
    <updated>2017-08-29T10:15:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中，cocoa touch框架是一个非常稳定和成熟的框架，这样的一个优秀框架，必然少不了设计模式的存在。本文将设计模式的讲解过渡到iOS设计中，体会历史沉淀下来的设计模式的精妙<br><a id="more"></a></p>
<h5 id="1、工厂模式"><a href="#1、工厂模式" class="headerlink" title="1、工厂模式"></a>1、工厂模式</h5><ul>
<li><strong>结构图：</strong></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2070409-b41ef6a9a9f3733e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工厂模式"></p>
<ul>
<li><strong>是什么：</strong><ul>
<li>提供一个类似工厂加工的方法，创建具体对象，返回抽象类型</li>
<li>具体生成什么类型在工厂内部进行判断</li>
<li>最后抽象类型（父类）指向具体对象，作为产品</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>工厂方法具有面向对象的优点，古代没有活字印刷的时候，直接进行雕刻，是面向过程的，复用和维护都非常困难，活字印刷是面向对象的，类似工厂方法，维护和复用都很方便</li>
<li>将具体产生什么类型隐藏起来，将产生什么类型交给子类决定</li>
</ul>
</li>
<li><strong>哪里有：</strong><ul>
<li>NSNumber的API中，有类初始化方法，将会产生两种类型，NSCFBoolean和NSCFNumber，这两个类仍然是工厂，而不属于具体对象，继续往下，NSCFBoolean和NSCFNumber的intValue和boolValue方法将会生成具体的对象，NSCFBoolean和NSCFNumber就是所谓的工厂模式的体现</li>
</ul>
</li>
</ul>
<h5 id="2、抽象工厂"><a href="#2、抽象工厂" class="headerlink" title="2、抽象工厂"></a>2、抽象工厂</h5><ul>
<li><p><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-e4c41e5d8303bb20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="抽象工厂"></p>
</li>
<li><p><strong>是什么：</strong></p>
<ul>
<li>可以是一个接口或者一个类，有很多工厂会实现这个接口或者继承这个类</li>
<li>抽象工厂模式相当于多个工厂实现了统一接口或者继承了同一个类</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>如果只有一种类型的工厂，那么用工厂模式即可，但是有些情况下会存在同类的多个工厂，这时候就扩展为抽象工厂</li>
</ul>
</li>
<li><strong>哪里有：</strong>NSNumber调用类初始化方法后，返回的对象是NSCFBoolean和NSBoolean工厂，这两个工厂继承于NSNumber，拥有同样的一些方法，例如intValue和boolValue，在NSNumber的角度看，这就是抽象工厂，同时iOS中把抽象工厂别名为“类簇”</li>
</ul>
<h5 id="3、装饰者"><a href="#3、装饰者" class="headerlink" title="3、装饰者"></a>3、装饰者</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-740ea4279e4bc2d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="装饰者"></li>
<li><strong>是什么：</strong><ul>
<li>原始的类和装饰者接口共同实现一个接口（如果只有一个装饰者类的话，那么就可以不用接口）</li>
<li>装饰类中有一个接口类型的对象</li>
<li>装饰类中有新的方法，内嵌在接口的方法中</li>
<li>装饰类对象和原始类对象都可以作为装饰类对象的接口类型对象</li>
</ul>
</li>
<li><strong>哪里好：</strong>会思考的人可能发现，这种模式其实可以用子类化的形式来进行，那到底优点在哪里呢<ul>
<li>装饰类不会破坏原始类的性质，同时也添加不同的特性（这点子类化也能做到）</li>
<li>装饰类中的对象既可以是原始类对象，有也可以是其他装饰类对象，这样就能很方便的出现多种类型组合，而用子类化的方式去做到话，将会产生大量子类</li>
</ul>
</li>
<li><strong>哪里有：</strong> iOS中的范畴（Category）是一种变相的装饰者模式，他的原理是在编译的时候动态为原来的类添加方法，而不是拥有一个原始类的实例，严格意义上不是装饰者，但是却和装饰者思想很像，在需要添加的功能很少的时候可以用Category</li>
</ul>
<h5 id="4、责任链模式"><a href="#4、责任链模式" class="headerlink" title="4、责任链模式"></a>4、责任链模式</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-485a05c6c16dcace.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="责任链"></li>
<li><strong>是什么：</strong><ul>
<li>责任链和装饰者很像，因为在实现统一接口的这些类中，都有一个自己接口的对象类型</li>
<li>但是又有所不同，装饰者是在统一的方法中添加新的功能，责任链则是都具有自己独一无二的功能</li>
<li>通过对象与对象之间的链接，构成一条完整的逻辑线</li>
<li>如同工厂里面的产品生产线，每个部门都有自己擅长的部分，只做自己的部分，其他部分交给其他部门来完成</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>将提交申请者和申请处理者之间的耦合解除，提交申请者不需要关心是谁在处理申请</li>
<li>处理者只需要关心自己擅长的部分，如果不会，则交给下一位去做</li>
</ul>
</li>
</ul>
<h5 id="5、观察者模式"><a href="#5、观察者模式" class="headerlink" title="5、观察者模式"></a>5、观察者模式</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-11c444e9de29092d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="观察者"></li>
<li><strong>是什么：</strong><ul>
<li>为对象之间添加一种依赖的关系，当某一方对象的属性发生变化的时候，另一方的对象<strong>自动</strong>进行相关更新操作</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>解除了相互依赖的对象之间过多的耦合，双方对对方的了解都很少</li>
<li>当一方对象属性变化时，另一方能自动做出相应的变化（这一点可以说是观察者模式的核心）</li>
</ul>
</li>
<li><strong>哪里有：</strong>iOS中有两种关于观察者模式的实现，一种是通知机制，一种是KVO机制，通知机制不是最原始的观察者模式，但是却在核心的思想上面进行适合iOS开发的修改，KVO能够很好诠释观察者模式<ul>
<li>通知机制<ul>
<li>使用了一个通知中心的单例来作为平台</li>
<li>被观察者为一个特定的类对象（NSNotification），该类的作用就是作为一种通知</li>
</ul>
</li>
<li>KVO<ul>
<li>观察者实现一个方法（update方法），如果是是一个对象要使用，则封装在对象的.m文件中，如果是视图控制器使用，贼在试图控制器中实现就好</li>
<li>被观察者需要添加观察者，一般来说我们会添加self，然后在当前控制器上实现方法，<strong>可能很多人都会使用这个，但是却不了解这个原理，这一步的操作实际上是将该控制器对象作为观察者添加了，实现的这个方法，其实就是观察者的update方法</strong></li>
<li>关于怎么在属性变化的时候通知观察者调用update方法，这个逻辑被封装到了KVO内部，自己也能试着模拟</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="6、命令模式"><a href="#6、命令模式" class="headerlink" title="6、命令模式"></a>6、命令模式</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-36abcdfb49948b83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令"></li>
<li><strong>是什么：</strong><ul>
<li>对于直接调用的方法，利用一个对象，将方法封装起来，被称为命令</li>
<li>并通过一个类似于“服务员”的角色和调用命令的对象进行交互</li>
</ul>
</li>
<li><strong>哪里好：</strong>命令模式从本质上来说，其实就是将直接调用的方法封装起来，变成一个对象，好处有这些<ul>
<li>封装起来，相当于是一种延时操作，所以可以利用这种模式做撤销</li>
<li>同时可以为方法设置一个队列，具有执行顺序的队列，在什么时候执行也可以加以限制</li>
</ul>
</li>
<li><strong>哪里有：</strong><ul>
<li>NSInvocation<ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-3e816ba67912c894.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSInvocation"></li>
<li>NSInvocation的角色就是命令模式中的封装方法的命令类</li>
</ul>
</li>
<li>NSUndoManager<ul>
<li>NSUndoManager提供了撤销机制</li>
<li>NSUndoManger也是利用了NSInvocation类对象作为命令角色</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="7、备忘录模式"><a href="#7、备忘录模式" class="headerlink" title="7、备忘录模式"></a>7、备忘录模式</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-0bb7cfe490b5ce06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="备忘录"></li>
<li><strong>是什么：</strong><ul>
<li>捕获对象内部的状态，在对象之外封装起来，方便恢复</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>备忘录模式在很多场景都会使用，例如存档，游戏进度存储和读取等等</li>
</ul>
</li>
<li><strong>哪里有：</strong><ul>
<li>归档<ul>
<li>备忘录对象即为归档对象</li>
<li>被归档的对象为操作对象</li>
<li>文件系统则为备忘录管理者</li>
</ul>
</li>
<li>属性列表序列化</li>
</ul>
</li>
</ul>
<h5 id="8、组合模式"><a href="#8、组合模式" class="headerlink" title="8、组合模式"></a>8、组合模式</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-97c683f610c91501.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组合"></li>
<li><strong>是什么：</strong><ul>
<li>将<strong>同一类</strong>对象组合成树状结构，具有部分和整体的层次，但是部分和整体保持一致性</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>能够保证整体和单个的一致性，对外界的接口是一致的</li>
<li>对整体的处理能够遍历到所有局部个体</li>
</ul>
</li>
<li><strong>哪里有：</strong><ul>
<li>在UIKit框架中，UIView的设计能够非常明确地体现这种设计模式      <ul>
<li>UIView是可以添加UIView类以及它子类的对象的</li>
<li>UIView对象的渲染以及其他操作会遍历到子类去依次进行</li>
</ul>
</li>
<li>图示：<br><img src="http://upload-images.jianshu.io/upload_images/2070409-6fccd9996a89bf52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIView如何体现组合模式"></li>
</ul>
</li>
</ul>
<h5 id="9、单例模式"><a href="#9、单例模式" class="headerlink" title="9、单例模式"></a>9、单例模式</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-36ef811b3a9060ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单利"></li>
<li><strong>是什么：</strong>相信单例模式是iOS开发者非常熟悉的几个模式之一<ul>
<li>保证一个类仅有一个实例</li>
<li>同时提供一个访问该唯一实例的访问接口</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>当一个类只需要产生一个实例的时候会用到单例模式</li>
</ul>
</li>
<li><strong>哪里有：</strong>相信iOS开发者对一些存在于开发中的单例类已经非常熟悉<ul>
<li>UIApplication：控制iOS应用程序的类</li>
<li>UIAccelerometer：加速器感应的类</li>
<li>NSFileManager：文件管理的类</li>
</ul>
</li>
</ul>
<hr>
<p><strong>最后，还需要推荐一篇文章，是我在前年写的，现在看起来，还是蛮不错的一篇文章<a href="http://blog.csdn.net/nineteen_/article/details/47859353" target="_blank" rel="external">iOS单例设计模式详细讲解(单例设计模式不断完善的过程)</a></strong></p>
<h5 id="10、策略模式"><a href="#10、策略模式" class="headerlink" title="10、策略模式"></a>10、策略模式</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-c08f6eb0326c65cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="策略"></li>
<li><strong>是什么：</strong><ul>
<li>定义一系列的算法，将他们封装为对象，可以相互替换</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>策略模式的作用就是将大量的if else结构给除去，使用对象来执行操作</li>
<li>避免将算法的具体细节暴露给外部</li>
</ul>
</li>
<li><strong>哪里有：</strong><ul>
<li>MVC模式中涵盖了很多其他的模式，其中策略模式就是其中之一，策略模式在MVC模式中的体现为：控制器作为视图的策略类，视图在没有控制器的情况下，显示应该是一样的，但是不同的控制器将会给视图赋予不同的数据已经输出模式等</li>
</ul>
</li>
</ul>
<h5 id="11、原型模式"><a href="#11、原型模式" class="headerlink" title="11、原型模式"></a>11、原型模式</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-6f71ade94dcc4f52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型"></li>
<li><strong>是什么：</strong><ul>
<li>为一个类添加复制操作来创建新的对象</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>如果一个对象是组合对象（见组合模式），那么使用原型模式来为对象创建克隆方法较为方便</li>
</ul>
</li>
<li><strong>哪里有：</strong>原型模式在实际开发中使用的并不是很多，但是原型模式中克隆方法就有所讲究了，这里对克隆的方法简要说明一下：<ul>
<li>浅复制：<ul>
<li>只复制指向实际对象的指针，两个指针指向的仍然是一个资源</li>
<li><img src="http://upload-images.jianshu.io/upload_images/2070409-a9b98a52e818dafd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浅复制"></li>
</ul>
</li>
<li>深复制：<ul>
<li>复制指向对象的指针以及指针指向的资源</li>
<li><img src="http://upload-images.jianshu.io/upload_images/2070409-43a2214ea3b8b7a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="深复制"></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>具体iOS中的体现，跳转<a href="http://www.jianshu.com/p/c3d9d096debf" target="_blank" rel="external">iOS剖析深浅复制</a></p>
<h5 id="12、生成器模式"><a href="#12、生成器模式" class="headerlink" title="12、生成器模式"></a>12、生成器模式</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-079967a7adea9429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成器"></li>
<li><strong>是什么：</strong><ul>
<li>将创建对象的细节封装到其他类</li>
<li>将多样化的创建过程封装起来，用户只需要制定创建的类型即可</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>客户类中的创建代码不再需要大量if else进行判断创建，直接制定类型即可创建</li>
<li>将创建过程封装起来，变得非常稳定不易出错</li>
</ul>
</li>
<li><strong>和抽象工厂有什么区别：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-9e1885e6547ca12c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="区别"></li>
</ul>
<h5 id="13、代理模式"><a href="#13、代理模式" class="headerlink" title="13、代理模式"></a>13、代理模式</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-2e172ddc23102caf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代理"></li>
<li><strong>是什么：</strong><ul>
<li>一个类委托另外一个类去做一件事情</li>
</ul>
</li>
<li><strong>哪里有：</strong><ul>
<li>iOS中的协议、代理和委托对象构成了代理模式：<ul>
<li>协议：是约束代理对象需要进行的操作</li>
<li>代理：执行被指派的操作</li>
<li>委托：指派任务的角色</li>
<li>用UITableView来细化这种模式：<ul>
<li>UITableView：作为委托者，内部拥有一个代理对象，在创建视图的方法中（推测内部实现）会使用代理对象执行协议中的方法</li>
<li>UITableViewDelegate&amp;UITableViewDataSource：作为协议，约束了代理对象需要实现的方法</li>
<li>UIViewController（或者是为了系统瘦身自定定义的一个代理类）：实现了协议中的方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="14、适配模式"><a href="#14、适配模式" class="headerlink" title="14、适配模式"></a>14、适配模式</h5><ul>
<li><strong>结构图：</strong><ul>
<li>类适配模式：<br><img src="http://upload-images.jianshu.io/upload_images/2070409-04b8f88c246af19c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类适配器"></li>
<li>对象适配器模式：<br><img src="http://upload-images.jianshu.io/upload_images/2070409-45ba675b2bdc7db4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象适配器"></li>
</ul>
</li>
<li><strong>是什么：</strong><ul>
<li>一个类想要调用另外一个类的方法，但是却不兼容</li>
<li>利用适配器类包装不兼容的方法，变为兼容方法供其他类使用</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>在方法调用不兼容的时候使用</li>
</ul>
</li>
<li><strong>哪里有：</strong><ul>
<li>iOS开发中如果导入了某个SDK，如果SDK中有一些方法在你的APP中并不兼容，那么这个时候适配器模式就能大显神威<ul>
<li>利用协议为适配器类约定方法</li>
<li>将SDK中方法封装到协议方法中</li>
<li>并添加上自己APP中需要进行的处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="15、模板方法模式"><a href="#15、模板方法模式" class="headerlink" title="15、模板方法模式"></a>15、模板方法模式</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-e5f7ed4f4c7f663f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模板方法"></li>
<li><strong>是什么：</strong><ul>
<li>利用一个抽象类封装基本的方法，并提供一些需要让子类去完善的方法接口</li>
<li>在基本方法中调用这些需要让子类完善的方法，从而达到不同的子类可以根据不同的情况实现不同的代码</li>
</ul>
</li>
<li><strong>哪里有：</strong><ul>
<li>UIView的drawRect方法：该方法是用于描述UIView长什么样子的，这个方法留给子类去实现，从而实现不同绘制</li>
<li>UIViewController的设备不同方向的方法</li>
</ul>
</li>
</ul>
<h5 id="16、迭代器模式"><a href="#16、迭代器模式" class="headerlink" title="16、迭代器模式"></a>16、迭代器模式</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-396f7b524d381e8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="迭代器"></li>
<li><strong>是什么：</strong><ul>
<li>迭代器类中拥有需要遍历的集合的对象，在暴露出来的方法中操作集合对象</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>如果不想暴露集合内部的信息，那么可以使用迭代器模式，通过迭代器暴露的方法来对集合进行访问和操作</li>
</ul>
</li>
<li><strong>哪里有：</strong><ul>
<li>NSEnumerator是iOS中的迭代器类，可以对常用的集合对象进行访问和操作</li>
</ul>
</li>
</ul>
<h5 id="17、桥接模式"><a href="#17、桥接模式" class="headerlink" title="17、桥接模式"></a>17、桥接模式</h5><ul>
<li><p><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-02313a445933ab42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="桥接"></p>
</li>
<li><p><strong>是什么：</strong></p>
<ul>
<li>很多书上说：抽象部分和实现部分分离，但是我觉得这种解释很不容易理解</li>
<li>这里给出通俗的解释：相互关联的类中，每个类都具有类的抽象，同时也有具体类的实现，这种情况下，与其将两个类体系利用继承融合起来，还不如使用聚合/组合将两个类体现关联起来。</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>两个类体系对外界暴露的接口都是抽象的，所以修改一个类体系的类的具体实现是不会对另一个类体系造成影响的</li>
<li>可以有很多种组合方法，到底是A中拥有B，还是B中拥有A，都是可以实现的</li>
</ul>
</li>
</ul>
<h5 id="18、外观模式"><a href="#18、外观模式" class="headerlink" title="18、外观模式"></a>18、外观模式</h5><ul>
<li><strong>结构图：</strong><br><img src="http://upload-images.jianshu.io/upload_images/2070409-3a13cbd0c244163e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="外观"></li>
<li><strong>是什么：</strong><ul>
<li>为一组具有关联的接口提供一个统一的接口，简化调用</li>
</ul>
</li>
<li><strong>哪里好：</strong><ul>
<li>避免了必须知道一系列接口的调用细节才能完成功能的尴尬情况</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS开发中，cocoa touch框架是一个非常稳定和成熟的框架，这样的一个优秀框架，必然少不了设计模式的存在。本文将设计模式的讲解过渡到iOS设计中，体会历史沉淀下来的设计模式的精妙&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>找零钱</title>
    <link href="http://www.nineteen.me/2017/08/28/%E6%89%BE%E9%9B%B6%E9%92%B1/"/>
    <id>http://www.nineteen.me/2017/08/28/找零钱/</id>
    <published>2017-08-28T10:28:02.000Z</published>
    <updated>2017-08-28T10:28:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，数组中为不同的数代表不同钱的面值，同时给定一个需要兑换零钱的钱数，任意使用不同面值不同数量的钱来兑换，求一共有多少种方法<br><a id="more"></a></p>
<h5 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h5><ul>
<li><strong>思路</strong>：暴力递归</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int operation1(vector&lt;int&gt; A, int index, int aim) &#123;</div><div class="line">    int result = 0;</div><div class="line">    if (index == A.size()) &#123;</div><div class="line">        result = aim == 0 ? 1 : 0;</div><div class="line">    &#125; else &#123;</div><div class="line">        for (int i = 0; i * A[index] &lt;= aim; i++) &#123;</div><div class="line">            result += operation1(A, index + 1, aim - A[index] * i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h5><ul>
<li><strong>思路</strong>：记忆法，由于暴力递归中存在很多重复计算，所以记忆法使用一个二维数组去记录递归的结果值，避免了大量重复计算</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">int operation2(vector&lt;int&gt; A, int index, int aim, vector&lt;vector&lt;int&gt;&gt; &amp;map) &#123;</div><div class="line">    int result = 0;</div><div class="line">    if (index == A.size()) &#123;</div><div class="line">        result = aim == 0 ? 1 : 0;</div><div class="line">    &#125; else &#123;</div><div class="line">        int mapValue = 0;</div><div class="line">        for (int i = 0; i * A[index] &lt;= aim; i++) &#123;</div><div class="line">            mapValue = map[index + 1][aim - i * A[index]];</div><div class="line">            if (mapValue == -1) &#123;</div><div class="line">                result += operation2(A, index + 1, aim - i * A[index], map);</div><div class="line">            &#125; else &#123;</div><div class="line">                result += mapValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    map[index][aim] = result;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h5><ul>
<li><strong>思路</strong>：动态规划，记忆法只是简单地记录了递归的结果集，动态规划去寻找了结果集的计算顺序，找出关系，利用递推的公式去代替枚举过程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">int operation3(vector&lt;int&gt; A, int aim, vector&lt;vector&lt;int&gt;&gt; &amp;dp) &#123;</div><div class="line">    // 初始化DP矩阵的第一列</div><div class="line">    for (int i = 0; i &lt; A.size(); i++) &#123;</div><div class="line">        dp[i][0] = 1;</div><div class="line">    &#125;</div><div class="line">    // 初始化DP矩阵的第一行</div><div class="line">    for (int i = 0; i &lt;= aim; i++) &#123;</div><div class="line">        if (i % A[0] == 0) &#123;</div><div class="line">            dp[0][i] = 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // DP过程</div><div class="line">    for (int i = 1; i &lt; A.size(); i++) &#123;</div><div class="line">        for (int j = 1; j &lt;= aim; j++) &#123;</div><div class="line">            if (j &gt;= A[i]) &#123;</div><div class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - A[i]];</div><div class="line">            &#125; else &#123;</div><div class="line">                dp[i][j] = dp[i - 1][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return dp[A.size() - 1][aim];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组，数组中为不同的数代表不同钱的面值，同时给定一个需要兑换零钱的钱数，任意使用不同面值不同数量的钱来兑换，求一共有多少种方法&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>求连续子序列最大和</title>
    <link href="http://www.nineteen.me/2017/08/27/%E6%B1%82%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://www.nineteen.me/2017/08/27/求连续子序列最大和/</id>
    <published>2017-08-27T11:20:01.000Z</published>
    <updated>2017-08-31T12:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个无序数组，求最大的连续子数组的和<br><a id="more"></a></p>
<h5 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h5><ul>
<li><strong>思路</strong>：暴力解法，最大序列肯定以数组中某个数为起点，则依次遍历以每个点为起点的情况</li>
<li><strong>时间复杂度</strong>：O(n平方)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int maxSubSequence1(vector&lt;int&gt; A, int n) &#123;</div><div class="line">    int max = INT_MIN;</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        int tempSum = 0;</div><div class="line">        for (int j = i; j &lt; n; j++) &#123;</div><div class="line">            tempSum += A[j];</div><div class="line">            max = tempSum &gt; max ? tempSum : max;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h5><ul>
<li><p><strong>思路</strong>：分治思想，结果有三种情况：</p>
<ul>
<li>情况1：最大子序列在左边部分</li>
<li>情况2：最大子序列在右边部分</li>
<li>情况3：最大子序列横跨左右两个部分</li>
</ul>
<p>然后每次递归过程都返回三者最大即可</p>
</li>
<li><strong>时间复杂度</strong>：O(nlogn)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">int maxForThree(int A, int B, int C) &#123;</div><div class="line">    if (A &gt;= B &amp;&amp; A &gt;= C) &#123;</div><div class="line">        return A;</div><div class="line">    &#125;</div><div class="line">    return maxForThree(B, C, A);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int maxSubSequence2(vector&lt;int&gt; A, int left, int right) &#123;</div><div class="line">    if (left == right) &#123;</div><div class="line">        return A[left];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int middle = left + (right - left)/2;</div><div class="line">    </div><div class="line">    // 左半部分</div><div class="line">    int leftSum = 0;</div><div class="line">    int leftMax = INT_MIN;</div><div class="line">    for (int i = middle; i &gt;= 0; i--) &#123;</div><div class="line">        leftSum += A[i];</div><div class="line">        leftMax = leftSum &gt; leftMax ? leftSum : leftMax;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 右半部分</div><div class="line">    int rightSum = 0;</div><div class="line">    int rightMax = INT_MIN;</div><div class="line">    for (int i = middle + 1; i &lt; A.size(); i++) &#123;</div><div class="line">        rightSum += A[i];</div><div class="line">        rightMax = rightSum &gt; rightMax ? rightSum : rightMax;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return maxForThree(leftMax + rightMax, maxSubSequence2(A, left, middle), maxSubSequence2(A, middle + 1, right));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h5><ul>
<li><strong>思路</strong>：调整思考角度，暴力解法核心是最大子序列一定是以数组中某个数为起点，转变思维，最大子序列也一定是以数组中某个数为终点</li>
<li><strong>时间复杂度</strong>：O(n)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int maxSubSequence3(vector&lt;int&gt; A, int n) &#123;</div><div class="line">    int tempMax = A[0]; // 以该数结尾的序列的最大和</div><div class="line">    int resultMax = A[0];</div><div class="line">    for (int i = 1; i &lt; n; i++) &#123;</div><div class="line">        </div><div class="line">        if (tempMax &lt; 0) &#123;</div><div class="line">            tempMax = A[i];</div><div class="line">        &#125; else &#123;</div><div class="line">            tempMax += A[i];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        resultMax = tempMax &gt; resultMax ? tempMax : resultMax;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    return resultMax;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个无序数组，求最大的连续子数组的和&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UITableView性能调优</title>
    <link href="http://www.nineteen.me/2017/08/16/UITableView%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://www.nineteen.me/2017/08/16/UITableView性能调优/</id>
    <published>2017-08-16T13:47:31.000Z</published>
    <updated>2017-08-16T13:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>UITableView几乎是最常用的控件之一，在开发中，经常需要对UITableView进行性能调优，提高用户体验<br><a id="more"></a></p>
<h4 id="最基本的规则"><a href="#最基本的规则" class="headerlink" title="最基本的规则"></a>最基本的规则</h4><ul>
<li>cell的复用</li>
<li><code>heightForRowAtIndexPath</code>在<code>cellForRowAtIndexPath</code>之前调用，遵循UIScrollView中必须先计算contentSize<ul>
<li><code>cellForRowAtIndexPath</code>：仅仅当cell显示的时候才会调用</li>
<li><code>heightForRowAtIndexPath</code>：<ol>
<li>初始化的时候，如果有N行，那么会执行N次</li>
<li>调用reloadData方法，又会执行N次</li>
<li>显示的cell又会调用该方法</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="尽量少的cell种类"><a href="#尽量少的cell种类" class="headerlink" title="尽量少的cell种类"></a>尽量少的cell种类</h4><p>由于复用机制的存在，假设cell有M种，一个屏幕能容下的cell个数为N个，那么缓冲池中将会最多存在M x N个cell对象，而如果只有一种cell的话，最多只会有N个对象在缓存池中</p>
<h4 id="定高的cell使用rowHeight"><a href="#定高的cell使用rowHeight" class="headerlink" title="定高的cell使用rowHeight"></a>定高的cell使用rowHeight</h4><p>如果所有cell是统一高度的，那么避免使用代理方法去执行多次，直接设置rowHeight属性即可</p>
<h4 id="提前计算并缓存cell的高度"><a href="#提前计算并缓存cell的高度" class="headerlink" title="提前计算并缓存cell的高度"></a>提前计算并缓存cell的高度</h4><p>在基本规则中可以看到，<code>heightForRowAtIndexPath</code>方法会调用非常多的次数，如果将高度计算放在方法中，那么可想而知，CPU会存在大量的消耗。所以，对于cell高度的计算，应该在从网络获取到数据的时候就进行计算，并且把计算的结果缓存起来。具体的做法，可以在数据模型model对象中添加一个cell高度的属性，但是通常model类一般没有实现，就只有属性，所以最好的方式是添加到viewModel中。</p>
<h4 id="提前创建并缓存真正需要显示的数据"><a href="#提前创建并缓存真正需要显示的数据" class="headerlink" title="提前创建并缓存真正需要显示的数据"></a>提前创建并缓存真正需要显示的数据</h4><p>有些从服务器中拿到的数据，并不能用于视图的显示，这些数据需要做一些处理才能用于视图显示。同样，我们可以在基本规则中看到，<code>cellForRowAtIndexPath</code>也会执行多次，所以这些处理不应该直接放在该方法中。而应该在从网络获取到数据的时候就进行处理，同时缓存起来作为一个属性。通常这也是MVVM模式中VM所做的操作之一。</p>
<h4 id="按需加载cell"><a href="#按需加载cell" class="headerlink" title="按需加载cell"></a>按需加载cell</h4><p>在滑动的过程中，计算滚动目标范围内的cell进行加载，而不加载滑动过程中的cell，通过监听UIScrollView的代理方法来完成</p>
<h4 id="避免使用透明图层"><a href="#避免使用透明图层" class="headerlink" title="避免使用透明图层"></a>避免使用透明图层</h4><p>设置图层透明，系统会将透明图层和下面的视图进行混合，而这种操作属于渲染操作中很慢的操作</p>
<h4 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h4><p>如果自定义cell的时候存在大量的子控件，那么这时候需要选择使用异步绘制，来防止创建多个子对象，耗费CPU资源。开启子线程直接绘制元素而非创建对象。除此之外还可以通过重写drawRect方法进行元素的绘制，drawRect方法本身是异步的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UITableView几乎是最常用的控件之一，在开发中，经常需要对UITableView进行性能调优，提高用户体验&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>细说GCD</title>
    <link href="http://www.nineteen.me/2017/08/15/%E7%BB%86%E8%AF%B4GCD/"/>
    <id>http://www.nineteen.me/2017/08/15/细说GCD/</id>
    <published>2017-08-15T09:51:03.000Z</published>
    <updated>2017-08-16T01:19:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>GCD是多线程编程中很常用的技术，同时，作为一项重要的知识点，在面试中也是“常来之客”，本文通过API进行GCD的归纳和总结<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/2070409-b070ca5d73c382d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="GCD之前"><a href="#GCD之前" class="headerlink" title="GCD之前"></a>GCD之前</h4><p>在苹果引入GCD技术之前，Cocoa框架中的NSObject类提供了<code>performSelectorInBackground:withObject</code>和<code>performSelectorOnMainThread</code>等来实现多线程编程，此外还有NSThread、NSOperation等，伴随GCD的诞生，NSOperation也进行重写，基于GCD实现</p>
<h4 id="关于多线程编程"><a href="#关于多线程编程" class="headerlink" title="关于多线程编程"></a>关于多线程编程</h4><p>一个CPU一次只能执行一个命令，这样连续执行命令，相当于一条无分叉的路径，这样的路径就是“线程”。OS和iOS的核心XNU内核在进行操作系统事件处理的时候，会切换执行路径。每条执行路径的状态，会保存到每条路径专用的内存块中，便于下次执行时复原信息。这种来回切换的操作可以被称为“上下文切换”，也正是这种切换产生了多线程。</p>
<h4 id="多线程需要注意的问题"><a href="#多线程需要注意的问题" class="headerlink" title="多线程需要注意的问题"></a>多线程需要注意的问题</h4><ul>
<li>数据不一致：例如，两个线程同时更新一个数据</li>
<li>死锁：两个线程互相等待对方执行结束</li>
<li>内存消耗：线程过多会消耗大量内存<br>…</li>
</ul>
<h4 id="GCD的API"><a href="#GCD的API" class="headerlink" title="GCD的API"></a>GCD的API</h4><blockquote>
<p>dispatch_queue_t</p>
</blockquote>
<p>分为两种</p>
<ul>
<li><code>Serial Dispatch Queue</code>：串行队列<ul>
<li><strong>系统提供的</strong>：<code>dispatch_get_main_queue</code></li>
<li><strong>自定义创建</strong>：<code>dispatch_queue_create(&quot;name&quot;, DISPATCH_QUEUE_SERIAL)</code>其中的name是该queue的名字</li>
</ul>
</li>
<li><code>Concurrent Dispatch Queue</code>：并行队列<ul>
<li><strong>系统提供的</strong>：<code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT，0)</code>其中第一个参数有四种，对应不同优先级<ul>
<li><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code></li>
<li><code>DISPATCH_QUEUE_PRIORITY_LOW</code></li>
<li><code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code></li>
<li><code>DISPATCH_QUEUE_PRIORITY_HIGH</code></li>
</ul>
</li>
<li><strong>自定义创建</strong>：<code>dispatch_queue_create(&quot;name&quot;，DISPATCH_QUEUE_CONCURRENT)</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>dispatch_set_target_queue</p>
</blockquote>
<ul>
<li><p><code>dispatch_queue_create</code>生成的<code>dispatch_queue_t</code>的优先级都是默认优先级，如果想要改变优先级可以使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;name&quot;, DISPATCH_QUQUE_SERIAL);</div><div class="line">dispatch_queue_t queue2 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND);</div><div class="line">dispatch_set_target_queue(queue1, queue2);</div></pre></td></tr></table></figure>
</li>
<li><p>同时如果将多个串行队列的目标制定为同一个串行队列，那么本应该并行执行的各个串行队列只能串行地进行执行</p>
</li>
</ul>
<blockquote>
<p>dispatch_after</p>
</blockquote>
<p>在指定时间之后执行处理，本质上是在指定时间之后将任务追加到队列中</p>
<blockquote>
<p>dispatch_group_t</p>
</blockquote>
<p>队列组可以用来实现：当所有处理结束之后，执行一个操作。正常来说使用串行队列是很容易实现的，但是如果是并行队列的话，想要实现这个操作，就需要借助队列组来实现</p>
<blockquote>
<p>dispatch_group_notify</p>
</blockquote>
<ul>
<li>用于group中所有任务执行完之后追加一个操作执行</li>
<li>该方法不会阻塞当前线程</li>
</ul>
<blockquote>
<p>dispatch_group_wait</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">long result = dispatch_group_wait(group, time);</div></pre></td></tr></table></figure>
<ul>
<li>该函数会阻塞当前线程（即代码所处的线程）</li>
<li>time的选择<ul>
<li>可以是一个固定的时间，如果超时了，该函数就会返回</li>
<li>也可以是DISPATCH_TIME_FOREVER，表示一直等待，直到group中所有操作执行完毕，函数才返回。</li>
</ul>
</li>
<li>返回值<ul>
<li>0：代表group中的任务全部执行完了</li>
<li>非0：代表超时了</li>
</ul>
</li>
</ul>
<blockquote>
<p>dispatch_barrier_async</p>
</blockquote>
<p>一般来说，关于数据库的操作，使用串行队列能够避免数据异常的问题。但是实际上，读取操作之间是没有影响的，为了提高效率，读取操作通过是并行的，只需要保证写操作的时候，没有任何一个读取操作在进行即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dispatch_async(queue, block_reading1);</div><div class="line">dispatch_async(queue, block_reading2);</div><div class="line">dispatch_barrier_async(queue, block_writing);</div><div class="line">dispatch_async(queue, block_reading3);</div><div class="line">dispatch_async(queue, block_reading4);</div></pre></td></tr></table></figure>
<p>以上代码中的写操作，会等待上面代码中的读操作（已经被添加到队列中的任务）执行完毕之后，开始执行，此时，写操作以下的代码中的读操作需要的等待写操作执行完之后才能添加到队列中执行</p>
<blockquote>
<p>dispatch_async和dispatch_sync</p>
</blockquote>
<ul>
<li><code>dispatch_async</code>是异步执行，代表不会阻塞当前线程，会另外开辟线程执行任务</li>
<li><code>dispatch_sync</code>是同步执行，代表会阻塞当前线程，会在当前线程执行任务</li>
</ul>
<blockquote>
<p>dispatch_apply</p>
</blockquote>
<p>该函数可以将block中的任务指定次数加入到队列中，并且会阻塞当前线程，直到所有的任务全部执行完</p>
<blockquote>
<p>dispatch_suspend和dispatch_resume</p>
</blockquote>
<ul>
<li><code>dispatch_suspend</code>：挂起后，添加到队列中的任务，尚未执行的处理都会停止执行</li>
<li><code>dispatch_resume</code>：将会恢复以上操作</li>
</ul>
<blockquote>
<p>dispatch_semaphore_t</p>
</blockquote>
<p>GCD中的信号量，用于控制并行执行，在GCD中，控制并行可以通串行队列和dispatch_barrier_async来做，而信号量semaphore可以更加精确地控制并行</p>
<ul>
<li><code>dispatch_semaphore_create(number )</code>：number为信号量的初始量</li>
<li><code>dispatch_semaphore_wait(semaphore, time)</code><ul>
<li>其中time和group中是一样的</li>
<li>返回值：<ul>
<li>0：如果信号量大于等于1，返回0，同时将信息号量减去1</li>
<li>非0：超过指定时间（同时这时信号量为0）</li>
</ul>
</li>
</ul>
</li>
<li><code>dispatch_semaphore_signal(semaphore)</code>：将信号量+1</li>
</ul>
<blockquote>
<p>dispatch_once</p>
</blockquote>
<p>用于单例处理，相关代码只会执行一次（即使在多核情况下，也是安全的）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GCD是多线程编程中很常用的技术，同时，作为一项重要的知识点，在面试中也是“常来之客”，本文通过API进行GCD的归纳和总结&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Masonry源码——准备知识</title>
    <link href="http://www.nineteen.me/2017/08/04/Masonry%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94%E5%87%86%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.nineteen.me/2017/08/04/Masonry源码——准备知识/</id>
    <published>2017-08-04T02:04:04.000Z</published>
    <updated>2017-08-04T02:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Masonry是一个用于布局的轻量级开源框架，我们一般使用它来代替苹果原生的AutoLayout代码，使得代码更加舒适简洁。Masonry框架虽然很轻量，但是代码中使用了大量的block和链式编程的技巧，所以想要阅读Masonry框架源码，需要掌握这两方面的知识<br><a id="more"></a></p>
<h4 id="Block的常见使用"><a href="#Block的常见使用" class="headerlink" title="Block的常见使用"></a>Block的常见使用</h4><ul>
<li><strong>声明block类型变量</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int (^test)(int) = ^(int a) &#123;</div><div class="line">    return a + 1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><strong>block作为函数参数</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)test :(void (^)(NSString *a)) block &#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>block作为函数返回值</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void (^)(NSString *))block &#123;</div><div class="line">    return ^(NSString *a) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;,a);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时候我们也可以使用typedef来简化block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef void(^block)(NSString *a);</div><div class="line"></div><div class="line">- (block)block &#123;</div><div class="line">    return ^(NSString *a) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;,a);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)test :(block) block &#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="链式编程思想"><a href="#链式编程思想" class="headerlink" title="链式编程思想"></a>链式编程思想</h4><p>很多地方总会将链式编程和函数式编程结合在一起来谈论，这里先简单说明下两者的区别</p>
<ul>
<li><strong>函数式编程</strong>：<br>将函数作为和其他数据类型一样来进行操作，可以作为其他函数的参数和返回值等，例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">method1(method2(method3(3)));</div></pre></td></tr></table></figure>
<ul>
<li><strong>链式编程</strong><br>用点的形式连接函数，完成参数的传递和逻辑处理，例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make.top.equalTo(self.view).with.offset(5);</div></pre></td></tr></table></figure>
<p><strong>接着我们来看链式编程是如何实现的</strong><br>还是用一个最经典的例子来看，那就是计算器，我们先来看看整体的代码，再逐步分析</p>
<ul>
<li><strong>.h文件</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, assign) NSInteger result;</div><div class="line"></div><div class="line">+ (NSInteger)makeCalculator :(void(^)(Calculator * make)) block;</div><div class="line"></div><div class="line">- (Calculator * (^) (NSInteger))add;</div><div class="line">- (Calculator * (^) (NSInteger))sub;</div><div class="line">- (Calculator *)printResult;</div></pre></td></tr></table></figure>
<ul>
<li><strong>.m文件</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">+ (NSInteger)makeCalculator:(void (^)(Calculator * make))block &#123;</div><div class="line">    Calculator *calculator = [[Calculator alloc]init];</div><div class="line">    block(calculator);</div><div class="line">    return calculator.result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (Calculator *(^)(NSInteger))add &#123;</div><div class="line">    return ^(NSInteger temp) &#123;</div><div class="line">        self.result += temp;</div><div class="line">        return self;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (Calculator *(^)(NSInteger))sub &#123;</div><div class="line">    return ^(NSInteger temp) &#123;</div><div class="line">        self.result -= temp;</div><div class="line">        return self;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (Calculator *)printResult &#123;</div><div class="line">    NSLog(@&quot;%ld&quot;,(long)self.result);</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>使用</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[Calculator makeCalculator:^(Calculator *make) &#123;</div><div class="line">    make.add(2).sub(1).printResult.sub(3);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>看.h文件，有一个result成员属性来存储结果，方法大致分为了三种</p>
<ul>
<li><strong>类方法：makeCalculator</strong><ul>
<li>使用了block做参数，block中有一个Calculator对象</li>
<li>在实现中：<ul>
<li>初始化Calculator对象</li>
<li>交付给block作为参数</li>
<li>返回值为成员变量result</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回block的方法：add、sub</strong><ul>
<li>使用了block作为返回值</li>
<li>实现中：<ul>
<li>操作成员变量result</li>
<li>返回自身（链式编程的核心）</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回对象的方法：printResult</strong><ul>
<li>返回自身对象（满足链式编程）</li>
<li>打印操作</li>
</ul>
</li>
</ul>
<p>在看使用的代码</p>
<ul>
<li><strong>类方法的调用</strong></li>
<li><strong>链中的方法</strong>：<code>make.add(2).sub(1).printResult.sub(3);</code><br>可以发现在链中的调用都是通过点进行的，但是在OC中都是通过<br>[object method] 的形式调用的，这里分为两种：<ul>
<li><strong>返回值为block的方法</strong>：<ul>
<li>首先该方法返回值是一个block，调用起来相当于getter方法，所以等价于一个block的属性<code>@property (nonatomic, readonly) Calculator * (^add) (NSInteger);</code></li>
<li><em>调用过程可以分为两步</em>：</li>
<li>第一步：<code>(Calculator * (^)(NSInteger)) tempBlock = make.add;</code>这里make.add是获取了属性</li>
<li>第二步：<code>tempBlock(2);</code></li>
</ul>
</li>
<li><strong>返回值为对象的方法</strong>：<ul>
<li>在OC中，如果符合getter方法的格式，则可以通过点语法进行调用</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Masonry是一个用于布局的轻量级开源框架，我们一般使用它来代替苹果原生的AutoLayout代码，使得代码更加舒适简洁。Masonry框架虽然很轻量，但是代码中使用了大量的block和链式编程的技巧，所以想要阅读Masonry框架源码，需要掌握这两方面的知识&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AFNetworking源码——多线程</title>
    <link href="http://www.nineteen.me/2017/07/29/AFNetworking%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.nineteen.me/2017/07/29/AFNetworking源码——多线程/</id>
    <published>2017-07-29T00:46:08.000Z</published>
    <updated>2017-07-29T00:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于AFNetworking本质上是对NSURLConnection和NSURLSession进行了封装设计，作为一个优秀网络请求框架，必然对多线程这一块的处理有自己的良好设计，本文分别探究2.0和3.0时代对于多线程的设计方案<br><img src="http://upload-images.jianshu.io/upload_images/2070409-4a6c14e87c12f262.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a></p>
<h3 id="AFNetworking-2-0"><a href="#AFNetworking-2-0" class="headerlink" title="AFNetworking 2.0"></a>AFNetworking 2.0</h3><p>对于2.0时代，框架采用了NSURLConnection+NSOperation的模型，那么来分析一下AF是如何进行请求的管理，以及回调的处理的，我们尝试列出几种方案：</p>
<ul>
<li><p><strong>所有请求都在主线程中发送，并且回调处理也有主线程来完成</strong><br>这应该是最直接的方式，那我们来看下这个方式有什么不好的地方</p>
<ul>
<li>如果请求数量很多，那么主线程会消耗大量的CPU资源来做请求的发送和回调的处理，对于这么注重流畅度的iOS，该方法直接被淘汰了</li>
</ul>
</li>
<li><p><strong>开启一条子线程，在子线程中进行请求的同步发送，并且等待回调</strong><br>利用子线程做处理，就不会有上述问题，但是仍然存在一些不好的地方</p>
<ul>
<li>子线程由于需要接受回调，所以需要使用runLoop进行线程保活，这样即使回调完成，线程资源仍然得不到释放，如果请求数量很多，就意味着开辟很多条子线程，造成大量的资源浪费</li>
</ul>
</li>
<li><p><strong>AF的方案：启用一个子线程，异步发送请求，处理回调事件</strong><br>通俗来说，就是开辟一条专门用于请求管理的线程，下面为2.0中的源码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[self performSelector:@selector(operationDidStart)</div><div class="line">			  onThread:[[self class] networkRequestThread] 			withObject:nil</div><div class="line">		 waitUntilDone:NO</div><div class="line">		         modes:[self.runLoopModes allObjects]]</div></pre></td></tr></table></figure>
<h3 id="AFNetworking-3-0"><a href="#AFNetworking-3-0" class="headerlink" title="AFNetworking 3.0"></a>AFNetworking 3.0</h3><p>AF的3.0时代进行了大改动，其内部实现从基于NSURLConnection变成了NSURLSession，在3.0的<a href="http://www.jianshu.com/p/b09b82a93bbc" target="_blank" rel="external">设计思路</a>这这篇文章中解析了3.0是如何对NSURLSession进行封装的，这里我们直接看一下对应的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.operationQueue = [[NSOperationQueue alloc] init];</div><div class="line">self.operationQueue.maxConcurrentOperationCount = 1;</div><div class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</div></pre></td></tr></table></figure>
<ul>
<li>3.0以AFURLSessionManager为核心类，每个对象都拥有一个NSOperationQueue用于请求发送和回调管理（可以发现是一个串行队列）</li>
<li>如果要转化为NSURLSession，那么就相当于每个session拥有一个NSOperationQueue，然后一个session可以创建多个任务，这些任务是在串行队列中执行</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>之所以设计方式不同了，有原因来自：2.0时代的NSURLConnection是一个全局的设计，从调用方式也能发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;www.nineteen.me&quot;]];</div><div class="line">[NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc]init] completionHandler:^(NSURLResponse * __nullable response, NSData * __nullable data, NSError * __nullable connectionError) &#123;</div><div class="line">    // ...</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>而NSURLSession是将Session和task进行了分离，可以从使用看出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</div><div class="line">NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration</div><div class="line">                                                      delegate:self</div><div class="line">                                                 delegateQueue:[NSOperationQueue mainQueue]];</div><div class="line">NSURLSessionDataTask *task = [session dataTaskWithURL:[[NSURL alloc]initWithString:@&quot;&quot;]];</div><div class="line">[task resume];</div></pre></td></tr></table></figure>
<p>这样的设计就能够为每个session对象（AFURLSessionManager对象）添加独自的操作队列NSOperationQueue，分别进行各自的请求发送和回调管理。而2.0中使用全局设计，因此AF维护一条子线程专门用于管理所有的请求发送和回调处理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于AFNetworking本质上是对NSURLConnection和NSURLSession进行了封装设计，作为一个优秀网络请求框架，必然对多线程这一块的处理有自己的良好设计，本文分别探究2.0和3.0时代对于多线程的设计方案&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2070409-4a6c14e87c12f262.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AFNetworking源码——基本架构</title>
    <link href="http://www.nineteen.me/2017/07/28/AFNetworking%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/"/>
    <id>http://www.nineteen.me/2017/07/28/AFNetworking源码——基本架构/</id>
    <published>2017-07-28T09:48:31.000Z</published>
    <updated>2017-07-28T09:48:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间疯狂收割了一波offer之后，也发现了很多的不足，例如很多大公司的面试官会问：你看过开源框架的源码吗，233，第一次问到还好，一次又一次被问到未免还是有些尴尬，在深深的自我反省之后，觉得自己在底层知识方面确实有欠缺，利用这段空余时间，决定开启一段源码之旅<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/2070409-c0900baaff2f2d40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p><img src="http://upload-images.jianshu.io/upload_images/2070409-aa486acfb22ed5a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>从上图可以发现，AFNetwoking框架是一个比较简洁的框架，主要分为了几个部分</p>
<ul>
<li>网络通信模块：NSURLSession</li>
<li>网络状态监听模块：Reachability</li>
<li>网络通信安全模块：Security</li>
<li>网络通信序列化模块：Serialization</li>
<li>对UIKit框架扩展部分：UIKit（以Catagory形式添加特性）</li>
</ul>
<p>在这几个模块中，AFNetworking的核心模块是通信模块，在通信模块中有两个类，AFHTTPSessionManager和AFURLSessionManager，其中前者继承于后者，是对HTTP的专一化封装处理。大家都知道AFNetworking 3.0其实只是对NSURLSession做了封装处理，那接下来，就从源码角度来解释这个事情，在这之前我们先来看看使用NSURLSession和使用AFNetworking做网络请求在实现过程中有什么区别</p>
<h5 id="使用区别"><a href="#使用区别" class="headerlink" title="使用区别"></a>使用区别</h5><ol>
<li><strong>使用NSURLSession进行网络请求</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:[[NSURL alloc] initWithString:@&quot;https://www.nineteen.me&quot;]];</div><div class="line">NSURLSession *session = [NSURLSession sharedSession];</div><div class="line">NSURLSessionDataTask *task = [session dataTaskWithRequest:request</div><div class="line">                                       completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</div><div class="line">                                           NSString *dataString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</div><div class="line">                                           NSLog(@&quot;%@&quot;, dataString);</div><div class="line">                                       &#125;];</div><div class="line">[task resume];</div></pre></td></tr></table></figure>
<ol>
<li><strong>使用AFHTTPSessionManager进行网络请求</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[[NSURL alloc] initWithString:@&quot;http://www.nineteen.me&quot;]];</div><div class="line">[manager GET:@&quot;2017/07/24/iOS核心动画/&quot; parameters:nil progress:nil</div><div class="line">    success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</div><div class="line">      // Success</div><div class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</div><div class="line">      // error</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>可以发现使用AFHTTPSessionManager进行网络请求大致分为了两步：</p>
<ol>
<li>创建一个AFHTTPSessionManager对象</li>
<li>使用这个对象调用含有block的请求方法</li>
</ol>
<p>从调用上来看，AFNetworking的请求会更加易读和编写，接下来我们就看看这两部分在框架中是如何实现的</p>
<h5 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h5><ul>
<li>AFHTTPSessionManager类的架构<br><img src="http://upload-images.jianshu.io/upload_images/2070409-80614cd6298e4152.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<p>在方法列表中，大致分为两部分，第一部分是初始化方法</p>
<ul>
<li>类初始化</li>
<li>对象初始化</li>
</ul>
<p>manager这个类初始化方法是很常用的，我们去看它的实现，发现它也是调用了自己的对象初始化方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)manager &#123;</div><div class="line">    return [[[self class] alloc] initWithBaseURL:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那我们就先来研究一下第一个部分，初始化AFHTTPSessionManager的内部实现，我们首先来看看，初始化方法的函数调用栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- [AFHTTPSessionManager initWithBaseURL:]</div><div class="line">	- [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:] </div><div class="line">		- [AFURLSessionManager initWithSessionConfiguration:] // #1</div><div class="line">			- [NSURLSession sessionWithConfiguration:delegate:delegateQueue:] // #2</div><div class="line">			- [AFJSONResponseSerializer serializer] </div><div class="line">			- [AFSecurityPolicy defaultPolicy] </div><div class="line">			- [AFNetworkReachabilityManager sharedManager] </div><div class="line">		- [AFHTTPRequestSerializer serializer] </div><div class="line">		- [AFJSONResponseSerializer serializer]</div></pre></td></tr></table></figure>
<ul>
<li>#1：调用了父类AFURLSessionManager的初始化方法</li>
<li>#2：调用了原生类NSURLSession的初始化方法</li>
</ul>
<p>从上面的函数调用栈可以发现，AFNetworking的内部实现到栈底仍然是操作了原生的NSURLSession，从根本上只是对原生的NSURLSession做了封装操作，封装了一些序列化、通信安全等策略，提供简洁的API，方便用户编码。</p>
<p>了解了初始化之后，我们再来看看发送请求的内部实现，在这里就用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET:parameters:process:success:failure:</div></pre></td></tr></table></figure>
<p>方法作为例子来查看一下源码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- [AFHTTPSessionManager GET:parameters:process:success:failure:] </div><div class="line">	- [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] // #1 </div><div class="line">		- [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] // 获得NSMutableURLRequest</div><div class="line">		- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] //  #2</div><div class="line">			- [NSURLSession dataTaskWithRequest:] // #3</div><div class="line">			- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:] // 添加代理</div><div class="line">				- [AFURLSessionManagerTaskDelegate init]</div><div class="line">				- [AFURLSessionManager setDelegate:forTask:]</div><div class="line">	- [NSURLSessionDataTask resume]</div></pre></td></tr></table></figure>
<ul>
<li>#1、#2、#3这三个方法得到的是同一个对象，来自#3的NSURLSessionDataTask对象</li>
</ul>
<p>从这里也能发现请求操作内部实现也是和原生NSURLSession操作一样，创建task，调用resume发送请求</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>AFNetworking2.0和3.0区别很大，也是因为苹果废弃了NSURLConnection，而改用了NSURLSession，AFNetworking3.0实际上只是对NSURLSession所做的操作进行了高度封装，提供更加简洁的API供编码调用</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间疯狂收割了一波offer之后，也发现了很多的不足，例如很多大公司的面试官会问：你看过开源框架的源码吗，233，第一次问到还好，一次又一次被问到未免还是有些尴尬，在深深的自我反省之后，觉得自己在底层知识方面确实有欠缺，利用这段空余时间，决定开启一段源码之旅&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AFNetworking源码——设计思路</title>
    <link href="http://www.nineteen.me/2017/07/28/AFNetworking%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
    <id>http://www.nineteen.me/2017/07/28/AFNetworking源码——设计思路/</id>
    <published>2017-07-28T09:15:58.000Z</published>
    <updated>2017-07-28T09:40:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>AFNetworking是一个非常简洁的框架，关于基本架构，可以看看<a href="http://www.jianshu.com/p/4f8333ee3879" target="_blank" rel="external">这篇文章</a>，本文主要阐述AFNetworking在设计上是如何对NSURLSession封装的。本文大致分为两个部分，第一个部分为NSURLSession的设计，第二个部分为AFNetworking的封装设计<br><a id="more"></a></p>
<h5 id="一、NSURLSession设计"><a href="#一、NSURLSession设计" class="headerlink" title="一、NSURLSession设计"></a>一、NSURLSession设计</h5><p>NSURLSession主要由这几个部分组成：</p>
<ul>
<li>NSURLSession</li>
<li>NSURLSessionTask（拥有三种子类）</li>
<li>NSURLSessionConfiguration</li>
<li>代理方法</li>
</ul>
<p>首先我们通过一段Session的使用代码来看各部分之间的关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; // #1</div><div class="line">NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration</div><div class="line">                                                      delegate:self</div><div class="line">                                                 delegateQueue:[NSOperationQueue mainQueue]]; // #2</div><div class="line">NSURLSessionDataTask *task = [session dataTaskWithURL:[[NSURL alloc]initWithString:@&quot;&quot;]]; // #3</div><div class="line">[task resume];</div></pre></td></tr></table></figure>
<p>为了方便理解这几个部分之间的关系，这段代码采用了delegate进行回调处理</p>
<ul>
<li><p><strong>#1</strong>：创建了NSURLSessionConfiguration对象，该对象的工厂模式方法提供了三种对象</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#if FOUNDATION_SWIFT_SDK_EPOCH_AT_LEAST(8)</div><div class="line">@property (class, readonly, strong) NSURLSessionConfiguration *defaultSessionConfiguration;</div><div class="line">@property (class, readonly, strong) NSURLSessionConfiguration *ephemeralSessionConfiguration;</div><div class="line">#endif</div><div class="line"> + (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier NS_AVAILABLE(10_10, 8_0);</div></pre></td></tr></table></figure>
<p>  以上有三种方法，下面简要介绍下每种类型的特点 </p>
<ul>
<li><strong>defaultSessionConfiguration</strong>：默认的配置，和NSURLConnection的配置类似，使用硬盘来缓存数据（不同的是NSURLConnection的配置是全局的）</li>
<li><strong>ephemeralSessionConfiguration</strong>：不会将Cookie、缓存等存储到磁盘，而是放在内存中，程序退出时数据会消失（可以用于私密浏览）</li>
<li><strong>backgroundSessionConfigurationWithIdentifier</strong>：可以在应用程序挂起、退出、崩溃的情况下运行下载和上传任务，会在后台另外开启一个线程，但是系统会根据负载程度去调度这个线程的操作，可能会造成速度缓慢或者超时</li>
</ul>
<p>三种工厂提供了三种对象具有不同的特点，除此之外，NSURLSessionConfiguration拥有很多的属性可以进行配置<br><img src="http://upload-images.jianshu.io/upload_images/2070409-03cdc1d2c3447e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>  这里列出一些常用属性：</p>
<ul>
<li><code>@property NSTimeInterval timeoutIntervalForRequest;</code>：请求超时</li>
<li><code>@property NSTimeInterval timeoutIntervalForResource;</code>：资源超时</li>
<li><p><code>@property (nullable, copy) NSDictionary *HTTPAdditionalHeaders;</code>：请求头，配置如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">configuration.HTTPAdditionalHeaders = @&#123;@&quot;Accept&quot;: @&quot;application/json&quot;,</div><div class="line">                                            @&quot;Accept-Language&quot;: @&quot;en&quot;,</div><div class="line">                                            @&quot;Accept-Encoding&quot;: @&quot;&quot;,</div><div class="line">                                            @&quot;Authorization&quot;: @&quot;&quot;,</div><div class="line">                                            @&quot;Connection&quot;: @&quot;&quot;,</div><div class="line">                                            @&quot;User-Agent&quot;: @&quot;&quot;&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可以发现字典中的key都是标准的HTTP请求头的key，可以通过这种方式对请求头进行自定义配置</p>
</li>
<li><p><strong>#2</strong>：创建了NSURLSession对象，依赖于三个参数</p>
<ul>
<li><strong>NSURLSessionConfiguration</strong>：配置</li>
<li><strong>Delegate</strong>：代理对象</li>
<li><strong>DelegateQueue</strong>：代理队列，在NSURLConnection中往往需要指定代理队列，代表回调方法在哪个线程中执行，NSURLSession提供了类初始化方法，省略了代理队列的指定，默认为主线程的主队列</li>
</ul>
<p>除了这种方式之外，还可以通过单例模式提供的类方法创建，内部实现可能没有设置代理和代理队列，采用的是默认配置</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (class, readonly, strong) NSURLSession *sharedSession;</div></pre></td></tr></table></figure>
<p>  这里的session使用了delegate回调，苹果还提供了block回调的形式：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSURLSessionDataTask *task = [session dataTaskWithURL:[[NSURL alloc]initWithString:@&quot;&quot;]</div><div class="line">                                    completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</div><div class="line">                                        </div><div class="line">                                    &#125;];</div></pre></td></tr></table></figure>
</li>
<li><p><strong>#3</strong>：创建NSURLSessionTask对象，NSURLSession提供了这几种task类型</p>
<ul>
<li>NSURLSessionTask：超类，一般不具体使用</li>
<li>NSURLSessionDataTask：请求</li>
<li>NSURLSessionUploadTask：上传</li>
<li>NSURLSessionDownloadTask：下载</li>
</ul>
<p>它们之间的继承关系如下：<br><img src="http://upload-images.jianshu.io/upload_images/2070409-6d26f92b927eda6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
</ul>
<p><strong>总结</strong>：NSURLSession的设计主要有三个部分，三个部分相互独立又具有联系，<strong>NSURLSessionConfiguration</strong>进行配置管理。<strong>NSURLSession</strong>将配置，代理，代理队列等对象关联，用于创建任务。<strong>NSURLSessionTask</strong>是任务类，其对象具有操作该任务的各种方法，启动，暂停等，同时任务的回调提供两种方式，block和代理。</p>
<h4 id="二、AFNetworking的封装设计"><a href="#二、AFNetworking的封装设计" class="headerlink" title="二、AFNetworking的封装设计"></a>二、AFNetworking的封装设计</h4><p>这里先回忆一下在基本架构这篇文章中所提到的AFNetworking的使用代码被分为两个部分，第一个部分是初始化AFHTTPSessionManager对象，第二个部分是调用请求方法。<br><strong>先来看第一个部分</strong>，我们再次回顾一下方法的调用栈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- [AFHTTPSessionManager initWithBaseURL:]</div><div class="line">	- [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:] // #1</div><div class="line">		- [AFURLSessionManager initWithSessionConfiguration:] // #2</div><div class="line">			- [NSURLSession sessionWithConfiguration:delegate:delegateQueue:]</div><div class="line">			- [AFJSONResponseSerializer serializer] </div><div class="line">			- [AFSecurityPolicy defaultPolicy] </div><div class="line">			- [AFNetworkReachabilityManager sharedManager] </div><div class="line">		- [AFHTTPRequestSerializer serializer] </div><div class="line">		- [AFJSONResponseSerializer serializer]</div></pre></td></tr></table></figure>
<p>我们顺着方法调用栈，看方法具体实现细节，从而理解AFNetworking是如何封装NSURLSession的</p>
<ul>
<li><p><strong>#1</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithBaseURL:(NSURL *)url</div><div class="line">           sessionConfiguration:(NSURLSessionConfiguration *)configuration</div><div class="line">&#123;</div><div class="line">    self = [super initWithSessionConfiguration:configuration]; // &amp;1</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected</div><div class="line">    if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) &#123;</div><div class="line">        url = [url URLByAppendingPathComponent:@&quot;&quot;];</div><div class="line">    &#125;</div><div class="line">    self.baseURL = url;  // &amp;2</div><div class="line">    self.requestSerializer = [AFHTTPRequestSerializer serializer];</div><div class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <strong>&amp;1</strong>：这里调用了父类AFURLSessionManager的初始化方法<br>  <strong>&amp;2</strong>：设置了baseURL</p>
</li>
<li><p><strong>#2</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"> - (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    if (!configuration) &#123;</div><div class="line">        configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; // &amp;1</div><div class="line">    &#125;</div><div class="line">    self.sessionConfiguration = configuration;</div><div class="line">    // &amp;2</div><div class="line">    self.operationQueue = [[NSOperationQueue alloc] init];</div><div class="line">    self.operationQueue.maxConcurrentOperationCount = 1;</div><div class="line">    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; // &amp;3</div><div class="line">    // &amp;4</div><div class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line">    self.securityPolicy = [AFSecurityPolicy defaultPolicy];</div><div class="line">#if !TARGET_OS_WATCH</div><div class="line">    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</div><div class="line">#endif</div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];</div><div class="line">    self.lock = [[NSLock alloc] init];</div><div class="line">    self.lock.name = AFURLSessionManagerLockName;</div><div class="line">    // &amp;5</div><div class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</div><div class="line">        for (NSURLSessionDataTask *task in dataTasks) &#123;</div><div class="line">            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line">        for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;</div><div class="line">            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line">        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;</div><div class="line">            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <strong>&amp;1</strong>：确定配置对象（原生调用）<br>  <strong>&amp;2</strong>：设置一个队列，并设置为串行（最大并发为1），在&amp;3中创建session的时候作为参数（由于AFNetworking将AFURLSessionManager类作为了NSURLSession的代理，所以这里另外添加一个在子线程中的操作队列）<br>  <strong>&amp;3</strong>：创建NSURLSession对象（原生调用）<br>  <strong>&amp;4</strong>：设置AFNetworking中的序列化和安全策略（AF自己的模块封装）<br>  <strong>&amp;5</strong>：为每个task添加一个AF封装的Delegate，后文会提到</p>
</li>
</ul>
<p><strong>总结第一部分</strong><br>从上面的代码细节来看，AFHTTPSessionManager的初始化操作就是做了这些事情：</p>
<ul>
<li>获得了NSURLSessionConfiguration对象</li>
<li>创建了NSURLSession对象，并设置自身为代理类，添加了操作队列</li>
<li><p>设置了AF自己封装的序列化和安全策略</p>
<p>这样一来，就很容易看出，其实就是在原生的初始化操作上添加了一些AF自己封装的策略对象</p>
</li>
</ul>
<p><strong>接下来再看看第二部分</strong>，同样回顾一下调用栈<br>使用<code>GET:parameters:process:success:failure:</code>方法作为例子来查看一下源码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- [AFHTTPSessionManager GET:parameters:process:success:failure:] // #1</div><div class="line">	- [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] // #2</div><div class="line">		- [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] </div><div class="line">		- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]  // #3</div><div class="line">			- [NSURLSession dataTaskWithRequest:]</div><div class="line">			- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:] // #4</div><div class="line">				- [AFURLSessionManagerTaskDelegate init]</div><div class="line">				- [AFURLSessionManager setDelegate:forTask:] // #5</div><div class="line">	- [NSURLSessionDataTask resume]</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>#1</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                   parameters:(id)parameters</div><div class="line">                     progress:(void (^)(NSProgress * _Nonnull))downloadProgress</div><div class="line">                      success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success</div><div class="line">                      failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure</div><div class="line">&#123;</div><div class="line"></div><div class="line">    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot;</div><div class="line">                                                        URLString:URLString</div><div class="line">                                                       parameters:parameters</div><div class="line">                                                   uploadProgress:nil</div><div class="line">                                                 downloadProgress:downloadProgress</div><div class="line">                                                          success:success</div><div class="line">                                                          failure:failure];</div><div class="line"></div><div class="line">    [dataTask resume];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从表层能够看出返回了一个NSURLSessionDataTask对象，并且调用了resume操作（和原生一样），我们接着看下返回对象的方法是如何实现的</p>
</li>
</ul>
<ul>
<li><p><strong>#2</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> - (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</div><div class="line">                                       URLString:(NSString *)URLString</div><div class="line">                                      parameters:(id)parameters</div><div class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</div><div class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</div><div class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</div><div class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</div><div class="line">&#123;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; // &amp;1</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    // &amp;2</div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    dataTask = [self dataTaskWithRequest:request</div><div class="line">                          uploadProgress:uploadProgress</div><div class="line">                        downloadProgress:downloadProgress</div><div class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                failure(dataTask, error);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                success(dataTask, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <strong>&amp;1</strong>：创建了NSURLRequest，可以发现AF内部是通过Request的方式创建的task，而不是URL<br>  <strong>&amp;2</strong>：调用另外一个方法返回task对象</p>
</li>
<li><p><strong>#3</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    url_session_manager_create_task_safely(^&#123;</div><div class="line">        dataTask = [self.session dataTaskWithRequest:request]; // &amp;1</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; // &amp;2</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <strong>&amp;1</strong>：这部分就很熟悉了，利用原生的方式通过request来创建task对象，然后返回。到这里，就已经能明白关于task对象是如何被封装返回的<br>  <strong>&amp;2</strong>：按照名字来看，这里好像是为task对象添加代理方法的，我们继续往下研究</p>
</li>
<li><p><strong>#4</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">  - (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    // &amp;1</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line">    [self setDelegate:delegate forTask:dataTask]; // &amp;2</div><div class="line">    // &amp;3</div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <strong>&amp;1</strong>：新建了一个AFURLSessionManagerTaskDelegate对象，是AF自己封装的代理对象<br>  <strong>&amp;2</strong>：看样子还需要进一步查看设置代理的细节，这一个方法传入了代理对象和task对象，我们继续看<br>  <strong>&amp;3</strong>：将block赋值给delegate的block属性，方便回调</p>
</li>
<li><p><strong>#5</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  - (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(NSURLSessionTask *)task</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line">    NSParameterAssert(delegate);</div><div class="line"></div><div class="line">    [self.lock lock]; // &amp;1</div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; // &amp;2</div><div class="line">    [delegate setupProgressForTask:task];</div><div class="line">    [self addNotificationObserverForTask:task];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <strong>&amp;1</strong>：有个加锁操作，保证线程安全<br>  <strong>&amp;2</strong>：用task的taskIdentifiier属性为key，delegate为value来进行对应，到这里，可以知道AF是用字典将delegate和task一一对应的</p>
</li>
</ul>
<p><strong>总结第二部分</strong>：<br>通过上面的分析，可以看出第二部分实际上就是利用NSURLRequest去创建NSURLSessionTask对象。同时呢，AFURLSessionManager作为了NSURLSession的代理，AF内部自定义了一个AFURLSessionManagerTaskDelegate代理类，该类具有很多block属性。并且，AF在内部实现了NSURLSession的代理方法，方法实现中实现block赋值，代理类的block属性对外暴露，在合适的地方回调。AF将很多NSRULSession中的代理方法都变成block形式进行暴露，更加简洁。<br><img src="http://upload-images.jianshu.io/upload_images/2070409-9a342c8e6fe26da5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AFNetworking是一个非常简洁的框架，关于基本架构，可以看看&lt;a href=&quot;http://www.jianshu.com/p/4f8333ee3879&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;，本文主要阐述AFNetworking在设计上是如何对NSURLSession封装的。本文大致分为两个部分，第一个部分为NSURLSession的设计，第二个部分为AFNetworking的封装设计&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS核心动画</title>
    <link href="http://www.nineteen.me/2017/07/24/iOS%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB/"/>
    <id>http://www.nineteen.me/2017/07/24/iOS核心动画/</id>
    <published>2017-07-24T07:48:45.000Z</published>
    <updated>2017-07-24T11:54:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>动画是iOS中非常有趣的部分，同时也是提升用户交互体验的有力工具，本文主要分为两个部分，第一个部分讲解基础知识，第二个部分列举基本使用<br><a id="more"></a></p>
<h4 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h4><h5 id="1-1、动画相关框架"><a href="#1-1、动画相关框架" class="headerlink" title="1.1、动画相关框架"></a>1.1、动画相关框架</h5><p><img src="http://upload-images.jianshu.io/upload_images/2070409-6dd0ef1b06e4a6f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>从上图可以发现</p>
<ul>
<li>UIView在最上层</li>
<li>往下依次是CoreAnimation</li>
<li>CoreGraphics、Hardware</li>
</ul>
<h5 id="1-2、iOS系统框架"><a href="#1-2、iOS系统框架" class="headerlink" title="1.2、iOS系统框架"></a>1.2、iOS系统框架</h5><p><img src="http://upload-images.jianshu.io/upload_images/2070409-a678b1c3b50c6835.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>上图为iOS中的四层架构</p>
<ul>
<li><strong>UIView</strong>位于Cocoa Touch层</li>
<li><strong>CoreAnimation</strong>位于Media Layer中的QuartzCore框架中，查看QuartzCore的头文件可以发现，只引入了CoreAnimation。<strong>CALayer</strong>这个熟悉的对象是在CoreAnimation中，CoreAnimation往往作用于CALayer而不是UIView</li>
<li><strong>Core Graphics</strong>也是在Media Layer层中的框架</li>
</ul>
<h5 id="1-3、UIView、QuartzCore和CoreGraphics之间的关系"><a href="#1-3、UIView、QuartzCore和CoreGraphics之间的关系" class="headerlink" title="1.3、UIView、QuartzCore和CoreGraphics之间的关系"></a>1.3、UIView、QuartzCore和CoreGraphics之间的关系</h5><ul>
<li><strong>UIView</strong>：主要负责事件响应、页面展示和与RunLoop相关操作</li>
<li><strong>QuartzCore</strong>：不单负责动画的创建和执行，还会将图形图像最终显示到屏幕上（本质上是CoreAnimation通过OpenGLES来做的）</li>
<li><strong>CoreGraphics</strong>：是一个基于C的库函数的高级绘画引擎，负责创建最终显示到屏幕上的数据模型</li>
</ul>
<h5 id="1-4、UIView和CALayer的协同"><a href="#1-4、UIView和CALayer的协同" class="headerlink" title="1.4、UIView和CALayer的协同"></a>1.4、UIView和CALayer的协同</h5><ul>
<li>UIView都拥有一个CALayer，CALayer将UIView设置为了自己的代理对象</li>
<li>对于CALayer对象，改变其属性，都会触发一个简单动画</li>
<li>UIView禁止在默认情况下禁止了CALayer的动画，所以我们在改变UIView的属性的时候，不会触发动画，而在UIView的动画block中，我们又能产生动画，在原理上为：一个可动画的CALayer属性改变的时候，都会寻找并运行一个合适的改变，这个改变是CAAction对象，而UIView的CALayer对象会询问他的delegate，即UIView，询问提供一个CAAction对象，delegate可以通过下面三种方式之一进行响应<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1、它可以返回一个动作对象，这种情况下 layer 将使用这个动作。</div><div class="line">2、它可以返回一个 nil， 这样 layer 就会到其他地方继续寻找。</div><div class="line">3、它可以返回一个 NSNull 对象，告诉 layer 这里不需要执行一个动作，搜索也会就此停止。</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="1-5、UIView和CALayer的关系"><a href="#1-5、UIView和CALayer的关系" class="headerlink" title="1.5、UIView和CALayer的关系"></a>1.5、UIView和CALayer的关系</h5><ul>
<li>UIView的属性只是简单地返回了CALayer对象的属性</li>
<li>UIView作为CALayer的代理，负责事件处理功能，CALayer负责页面绘制（前面也提到了CoreAnimation的作用）</li>
</ul>
<h4 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h4><h5 id="2-1、Core-Animation类图"><a href="#2-1、Core-Animation类图" class="headerlink" title="2.1、Core Animation类图"></a>2.1、Core Animation类图</h5><p><img src="http://upload-images.jianshu.io/upload_images/2070409-d1060614eb08a72b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="2-2、类别"><a href="#2-2、类别" class="headerlink" title="2.2、类别"></a>2.2、类别</h5><p>我们常用到的为下面四种：</p>
<ul>
<li><strong>CAAnimationGroup</strong>：动画组，将不同类型的动画同时进行或者连续进行</li>
<li><strong>CABasicAnimation</strong>：基本动画，包括一些基本属性的动画，例如位移、缩放、渐变等</li>
<li><strong>CAKeyFrameAnimation</strong>：关键帧动画，连续进行多个阶段的动画</li>
<li><strong>CATransition</strong>：过渡动画</li>
</ul>
<p>除了上面四种，还有一种是iOS9之后提供的弹簧动画<strong>CASpringAnimation</strong><br>另外，CoreGraphics中提供了<strong>仿射变化动画</strong>，可以很方便地进行一些基本动画操作</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动画是iOS中非常有趣的部分，同时也是提升用户交互体验的有力工具，本文主要分为两个部分，第一个部分讲解基础知识，第二个部分列举基本使用&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Masonry中的优先级</title>
    <link href="http://www.nineteen.me/2017/07/01/Masonry%E4%B8%AD%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://www.nineteen.me/2017/07/01/Masonry中的优先级/</id>
    <published>2017-07-01T11:45:40.000Z</published>
    <updated>2017-07-24T11:27:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="可能标题不能够完全解释清楚本文到底要描述什么，没关系，我们来举出一个实际的例子，看下图："><a href="#可能标题不能够完全解释清楚本文到底要描述什么，没关系，我们来举出一个实际的例子，看下图：" class="headerlink" title="可能标题不能够完全解释清楚本文到底要描述什么，没关系，我们来举出一个实际的例子，看下图："></a>可能标题不能够完全解释清楚本文到底要描述什么，没关系，我们来举出一个实际的例子，看下图：</h3><p><img src="http://upload-images.jianshu.io/upload_images/2070409-595fda6c03a18609.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="红框中的我们发现在第一行一共有三个控件，一个是标题的UILabel（表示为：headLineTabel），一个是宝石的图标UIImageView（表示为：diamondImageView），再有一个是宝石的数量UILabel（表示为：diamondLabel），这时候我们用Masonry编写代码的时候往往一般是这样的思路："><a href="#红框中的我们发现在第一行一共有三个控件，一个是标题的UILabel（表示为：headLineTabel），一个是宝石的图标UIImageView（表示为：diamondImageView），再有一个是宝石的数量UILabel（表示为：diamondLabel），这时候我们用Masonry编写代码的时候往往一般是这样的思路：" class="headerlink" title="红框中的我们发现在第一行一共有三个控件，一个是标题的UILabel（表示为：headLineTabel），一个是宝石的图标UIImageView（表示为：diamondImageView），再有一个是宝石的数量UILabel（表示为：diamondLabel），这时候我们用Masonry编写代码的时候往往一般是这样的思路："></a>红框中的我们发现在第一行一共有三个控件，一个是标题的UILabel（表示为：headLineTabel），一个是宝石的图标UIImageView（表示为：diamondImageView），再有一个是宝石的数量UILabel（表示为：diamondLabel），这时候我们用Masonry编写代码的时候往往一般是这样的思路：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 钻石数量label</span></div><div class="line">[<span class="keyword">self</span>.contentView addSubview:<span class="keyword">self</span>.diamondLabel];</div><div class="line">[<span class="keyword">self</span>.diamondLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.right.equalTo(<span class="keyword">self</span>.contentView).with.offset(<span class="number">-13</span> * AutoLayoutScaleX);</div><div class="line">    make.top.equalTo(<span class="keyword">self</span>.contentView).with.offset(<span class="number">13</span> * AutoLayoutScaleY);</div><div class="line">    </div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 钻石imageView</span></div><div class="line">[<span class="keyword">self</span>.contentView addSubview:<span class="keyword">self</span>.diamondImageView];</div><div class="line">[<span class="keyword">self</span>.diamondImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.right.equalTo(<span class="keyword">self</span>.diamondLabel.mas_left).with.offset(<span class="number">-2</span> * AutoLayoutScaleX);</div><div class="line">    make.centerY.equalTo(<span class="keyword">self</span>.diamondLabel);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 标题label</span></div><div class="line">[<span class="keyword">self</span>.contentView addSubview:<span class="keyword">self</span>.headLineLabel];</div><div class="line">[<span class="keyword">self</span>.headLineLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">    make.left.equalTo(<span class="keyword">self</span>.contentView).with.offset(<span class="number">10</span> * AutoLayoutScaleX);</div><div class="line">    make.centerY.equalTo(<span class="keyword">self</span>.diamondLabel);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h5 id="但是这样的布局所造成的效果肯定不可能是上图所示，因为headLineLabel和diamondImageView之间没有设置约束，所以如果headLine的长度过于长，将会和diamondImageView相互重叠，本文就是要讲解解决这个问题的方法。"><a href="#但是这样的布局所造成的效果肯定不可能是上图所示，因为headLineLabel和diamondImageView之间没有设置约束，所以如果headLine的长度过于长，将会和diamondImageView相互重叠，本文就是要讲解解决这个问题的方法。" class="headerlink" title="但是这样的布局所造成的效果肯定不可能是上图所示，因为headLineLabel和diamondImageView之间没有设置约束，所以如果headLine的长度过于长，将会和diamondImageView相互重叠，本文就是要讲解解决这个问题的方法。"></a>但是这样的布局所造成的效果肯定不可能是上图所示，因为headLineLabel和diamondImageView之间没有设置约束，所以如果headLine的长度过于长，将会和diamondImageView相互重叠，本文就是要讲解解决这个问题的方法。</h5><ul>
<li><p><strong>问题出现原因</strong></p>
<ol>
<li>没有直接对带有文字的UILabel进行宽度的约束</li>
<li>两个会相互重叠的控件之间没有设置约束</li>
</ol>
</li>
<li><p><strong>思考</strong></p>
<ol>
<li>先来试试直接对UILable计算宽度来进行写死的约束，这样的话我也应该将其他控件的宽度也写死才能成功编译，但是这样我就需要算好两个控件的宽度，而最好的其实是不限制他们，让他们自己知道怎么“谦让”对方</li>
<li>在两个控件之间设置约束，由于宽度都没有限制，所以这样写，从原理上分析，是肯定会报错的（当然实际也会报错）</li>
<li>问题已经由上面两个点抛出，那么实际上解决这个问题的方法是设置各个控件的优先级，让他们自己知道自己是什么样的地位的，低地位的控件需要谦让高地位的控件，让高地位的控件优先将自己显示完全</li>
</ol>
</li>
<li><p><strong>解决办法</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 标题label</span></div><div class="line">    [<span class="keyword">self</span>.contentView addSubview:<span class="keyword">self</span>.headLineLabel];</div><div class="line">    [<span class="keyword">self</span>.headLineLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.left.equalTo(<span class="keyword">self</span>.contentView).with.offset(<span class="number">10</span> * AutoLayoutScaleX);</div><div class="line">        make.centerY.equalTo(<span class="keyword">self</span>.diamondLabel);</div><div class="line">        make.right.mas_lessThanOrEqualTo(<span class="keyword">self</span>.diamondLabel.mas_left).with.offset(<span class="number">-5</span> * AutoLayoutScaleX);</div><div class="line">    &#125;];</div><div class="line"><span class="comment">// 设置优先级</span></div><div class="line">    [<span class="keyword">self</span>.diamondImageView setContentCompressionResistancePriority:<span class="built_in">UILayoutPriorityRequired</span> forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</div><div class="line">    [<span class="keyword">self</span>.diamondLabel setContentCompressionResistancePriority:<span class="built_in">UILayoutPriorityRequired</span> forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</div><div class="line"></div><div class="line">    [<span class="keyword">self</span>.headLineLabel setContentCompressionResistancePriority:<span class="built_in">UILayoutPriorityDefaultLow</span> forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</div></pre></td></tr></table></figure>
</li>
<li><p><strong>代码分析和解释</strong></p>
<ol>
<li>在headLineLabel的布局中添加了一个约束，即为headLineLabel和diamondImageView之间的约束，但是所使用的不是equalTo，而是mas_lessThanOrEqualTo，表示极限的情况是等于，一般来说是小于</li>
<li>优先级函数：<ul>
<li>第一个参数：通俗来讲，不同的优先级，表示显示的完整性的高低，优先级越高，那么在父控件无法在无越界的情况下的情况下，就会优先先把优先级高的控件显示完整，然后再依次显示优先级低的</li>
<li>第二个参数：代表在什么方向上进行优先级限制</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;可能标题不能够完全解释清楚本文到底要描述什么，没关系，我们来举出一个实际的例子，看下图：&quot;&gt;&lt;a href=&quot;#可能标题不能够完全解释清楚本文到底要描述什么，没关系，我们来举出一个实际的例子，看下图：&quot; class=&quot;headerlink&quot; title=&quot;可能标题
    
    </summary>
    
    
  </entry>
  
</feed>
