<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Runtime和它的消息机制 · Nineteen</title><meta name="description" content="Runtime和它的消息机制 - 郑祯"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.nineteen.me/atom.xml" title="Nineteen"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">Nineteen</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>INDEX</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>ARCHIVES</p></a><a href="/about" target="_self" class="li component-nav-item"><p>ME</p></a><ul class="shortcut-icons"><a href="http://www.jianshu.com/u/dd2dfc34332d" target="_blank"><img src="/images/jianshu.svg" class="icon"></a><a href="https://weibo.com/6420611455/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank"><img src="/images/weibo.svg" class="icon"></a><a href="https://github.com/NtZheng" target="_blank"><img src="/images/github.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">Runtime和它的消息机制</h1><div class="post-info">Sep 2, 2017</div><div class="post-content"><p>Objective-C这门语言，众所周知，是对C进行了扩展，具体来说进行了两个方面的扩展，面向对象的特性和smalltalk中的消息传递。而消息传递机制归根结底是建立在Runtime库上。正是这种机制，决定了Objective-C是一门动态语言，而同样是对C扩展的C++，是静态的。Objective-C将很多决定性的操作依靠Runtime在运行时处理，而C++仅仅在编译时就决定了如何处理<br><a id="more"></a></p>
<h5 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h5><p>在我们所熟悉的调用方法背后，最终都是以消息传递的方式进行处理，例如<code>[object method]</code>，从表面上来看，是object调用了method方法，实际上，在运行时，是给object发送了一条method消息，这条消息不一定非要object来处理，也可以转发给其他的对象处理，也可以不进行处理，这些种种操作，都是利用Runtime在运行时处理的。<br>对于<code>[object method]</code>的调用，编译器会将其编译成一行C语言的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(object, @selector(method));</div></pre></td></tr></table></figure>
<h5 id="消息传递的步骤"><a href="#消息传递的步骤" class="headerlink" title="消息传递的步骤"></a>消息传递的步骤</h5><p>了解了消息传递之后，需要进一步知道消息传递的具体步骤：</p>
<ol>
<li>先查看method方法是不是需要被忽略</li>
<li>查看object对象是否为nil（Objective-C中允许空对象调用任何方法的原因）</li>
<li>查看缓存中是否存在方法，系统把近期发送过的消息记录在其中，苹果认为这样可以提高效率</li>
<li>如果缓存中没有命中，那么查找该类的方法表，依次从后往前查找</li>
<li>如果没有找到，则进入父类查找</li>
<li>如果到了根类还是没有找到的话，那么就进入动态解析</li>
</ol>
<h5 id="Runtime中的基本类型"><a href="#Runtime中的基本类型" class="headerlink" title="Runtime中的基本类型"></a>Runtime中的基本类型</h5><p>以上过程虽然读起来蛮容易理解的，但是我们还得搞清楚Runtime是通过什么进行上述操作的，这时候就需要对Runtime的一些基本类型进行了解，我们可以在<code>objc/objc.h</code>中看到以下这些定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">struct objc_object &#123;  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct objc_class &#123;  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class;</div><div class="line">    const char *name;</div><div class="line">    long version;</div><div class="line">    long info;</div><div class="line">    long instance_size;</div><div class="line">    struct objc_ivar_list *ivars;</div><div class="line">    **struct objc_method_list **methodLists**;</div><div class="line">    **struct objc_cache *cache**;</div><div class="line">    struct objc_protocol_list *protocols;</div><div class="line">#endif</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct objc_method_list &#123;  </div><div class="line">    struct objc_method_list *obsolete;</div><div class="line">    int method_count;</div><div class="line"></div><div class="line">#ifdef __LP64__</div><div class="line">    int space;</div><div class="line">#endif</div><div class="line"></div><div class="line">    /* variable length structure */</div><div class="line">    struct objc_method method_list[1];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct objc_method &#123;  </div><div class="line">    SEL method_name;</div><div class="line">    char *method_types;    /* a string representing argument/return types */</div><div class="line">    IMP method_imp;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>不难发现，基本每个结构都是C语言中的结构体，<code>object_object</code>对应着object，<code>object_class</code>对应着对象所属于的类，我们先把目光主要集中在<code>object_class</code>这个结构体上，可以发现几个上述步骤涉及到的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class; // 父类</div><div class="line">    const char *name; // 类名</div><div class="line">    long version; </div><div class="line">    long info;</div><div class="line">    long instance_size;</div><div class="line">    struct objc_ivar_list *ivars;</div><div class="line">    **struct objc_method_list **methodLists**; // 方法列表</div><div class="line">    **struct objc_cache *cache**; // 缓存</div><div class="line">    struct objc_protocol_list *protocols;</div><div class="line">#endif</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="再次理解消息传递的步骤"><a href="#再次理解消息传递的步骤" class="headerlink" title="再次理解消息传递的步骤"></a>再次理解消息传递的步骤</h5><p>理解了Runtime的基本结构后，我们再次用专业的角度来理解消息传递：</p>
<ol>
<li>查看method方法是否需要被忽略</li>
<li>查看object对象是否为nil</li>
<li>通过objc_object中的isa指针，找到该object的objc_class，然后查看objc_cache类型的cache成员中是否有这个方法，如果有，则找到objc_method中的IMP类型（函数指针）的成员method_imp去找到实现内容，并执行。</li>
<li>如果没有找到，则查看objc_method_list类型的成员methodLists中是否有该方法</li>
<li>如果没有找到，则通过Class类型的成员super_class找到父类的objc_class，进行查找</li>
<li>要是还没有找到，则进入动态解析</li>
</ol>
<h5 id="如果是调用类方法呢"><a href="#如果是调用类方法呢" class="headerlink" title="如果是调用类方法呢"></a>如果是调用类方法呢</h5><p>再次查看这个objc_class的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;  </div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY; // metaclass</div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class;</div><div class="line">    const char *name;</div><div class="line">    long version;</div><div class="line">    long info;</div><div class="line">    long instance_size;</div><div class="line">    struct objc_ivar_list *ivars;</div><div class="line">    **struct objc_method_list **methodLists**;</div><div class="line">    **struct objc_cache *cache**;</div><div class="line">    struct objc_protocol_list *protocols;</div><div class="line">#endif</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>刚刚第一次看的时候可能没有注意到第一个成员，第一个成员指向的是结构是metaclass，其中包含静态成员变量和静态方法（类方法），同时也包含了一个isa成员，都指向了父类的metaclass，如果是根类，则指向自己。所以如果是调用类方法的话，那么就会利用objc_class中的成员isa找到metaclass，然后寻找方法，没有找到的话则仍然进入动态解析。</p>
<h5 id="动态解析"><a href="#动态解析" class="headerlink" title="动态解析"></a>动态解析</h5><p>通过第二次的理解，对于消息传递有了一个清晰的了解，我们继续来研究消息传递最后一步的动态解析。正常我们如果调用了一个没有实现的方法，那么程序会崩溃，并且抛出<code>unrecognized selector to ...</code>的异常，但是利用Runtime，我们可以有三次机会避免程序崩溃，先通过一张图来大致了解下过程：<br><img src="http://upload-images.jianshu.io/upload_images/2070409-1bcb07b36efa1c0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们具体看下三种方法：</p>
<ul>
<li><code>resovleInstanceMethod</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void otherEat(id self, SEL cmd) &#123;</div><div class="line">    NSLog(@&quot;郑明明&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    if ([NSStringFromSelector(sel) isEqualToString:@&quot;eat&quot;]) &#123;</div><div class="line">        class_addMethod(self, sel, (IMP)otherEat, &quot;v@&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上需要注意几个地方：</p>
<ol>
<li><code>otherEat</code>函数是要被<code>class_addMethod</code>作为参数的，而<code>class_addMethod</code>是Runtime中的API，所以是基于C的，<code>otherEat</code>函数应该是C语言格式的函数</li>
<li>class_addMethod方法可谓是核心，那么依次来看他的参数的含义：<ul>
<li>first：添加到哪个类</li>
<li>second：添加哪个SEL选择器</li>
<li>third：IMP函数指针</li>
<li>fourth：IMP指针指向的函数返回值和参数类型<ul>
<li>v@：代表返回值是void类型，无参数<ul>
<li>i@：代表返回值是int类型，无参数</li>
<li>v@:i@：代表返回值是void类型，参数是int类型，存在一个参数（多参数依次累加）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>如果没有调用class_addMethod成功添加方法，那么就会到下一个方法</p>
<ul>
<li><code>forwardingTargetForSelector</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">//    return [[Woman alloc]init];</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果返回了另外一个对象，那么动态解析又会重新以另外一个对象为接受者执行，如果返回nil，则又继续进入到下一个方法</p>
<ul>
<li><code>methodSignatureForSelector</code> + <code>forwardInvocation</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;eat&quot;]) &#123;</div><div class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;@v&quot;];</div><div class="line">    &#125;</div><div class="line">    return [super methodSignatureForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</div><div class="line">    // 改变消息接受对象</div><div class="line">    /*</div><div class="line">    Woman *temp = [[Woman alloc]init];</div><div class="line">    [anInvocation invokeWithTarget:temp];</div><div class="line">     */</div><div class="line">    </div><div class="line">    // 改变执行的消息</div><div class="line">    [anInvocation setSelector:@selector(otherEat)];</div><div class="line">    [anInvocation invokeWithTarget:self];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>methodSignatureForSelector</code>方法返回一个返回值以及参数的封装值，然后会进入到下一个方法，<code>forwardInvocation</code>，这个方法的功能可以说是前两个方法的结合，通过操作NSInvocation对象，既可以改变需执行的消息，又可以改变消息的接受对象</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Runtime为Objective-C提供了很多可能，了解消息机制，更加有助于对Objective-C这门语言特性的掌握 </p>
</div></article></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'angrypowman';
var disqus_identifier = '2017/09/02/Runtime和它的消息机制/';
var disqus_title = 'Runtime和它的消息机制';
var disqus_url = 'http://www.nineteen.me/2017/09/02/Runtime和它的消息机制/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//angrypowman.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/2017/09/17/刨根问底，Block竟然是？/" class="prev">PREV</a><a href="/2017/08/29/iOS中那些精妙的设计模式/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://www.nineteen.me">郑祯</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"angrypowman",'auto');ga('send','pageview');</script></body></html>